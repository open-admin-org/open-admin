/*! choices.js v9.0.1 | Â© 2019 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define([], factory);
  else if (typeof exports === 'object')
    exports["Choices"] = factory();
  else
    root["Choices"] = factory();
})(window, function () {
  return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
        /******/
      }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
        /******/
      };
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
    }
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
        /******/
      }
      /******/
    };
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
      }
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
      /******/
    };
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
      /******/
    };
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/public/assets/scripts/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
    /******/
  })
/************************************************************************/
/******/([
/* 0 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var utils_1 = __webpack_require__(1);

      exports.DEFAULT_CLASSNAMES = {
        containerOuter: 'choices',
        containerInner: 'choices__inner',
        input: 'choices__input',
        inputCloned: 'choices__input--cloned',
        list: 'choices__list',
        listItems: 'choices__list--multiple',
        listSingle: 'choices__list--single',
        listDropdown: 'choices__list--dropdown',
        item: 'choices__item',
        itemSelectable: 'choices__item--selectable',
        itemDisabled: 'choices__item--disabled',
        itemChoice: 'choices__item--choice',
        placeholder: 'choices__placeholder',
        group: 'choices__group',
        groupHeading: 'choices__heading',
        button: 'choices__button',
        activeState: 'is-active',
        focusState: 'is-focused',
        openState: 'is-open',
        disabledState: 'is-disabled',
        highlightedState: 'is-highlighted',
        selectedState: 'is-selected',
        flippedState: 'is-flipped',
        loadingState: 'is-loading',
        noResults: 'has-no-results',
        noChoices: 'has-no-choices'
      };
      exports.DEFAULT_CONFIG = {
        items: [],
        choices: [],
        silent: false,
        renderChoiceLimit: -1,
        maxItemCount: -1,
        addItems: true,
        addItemFilter: null,
        removeItems: true,
        removeItemButton: false,
        editItems: false,
        duplicateItemsAllowed: true,
        delimiter: ',',
        paste: true,
        searchEnabled: true,
        searchChoices: true,
        searchFloor: 1,
        searchResultLimit: 4,
        searchFields: ['label', 'value'],
        position: 'auto',
        resetScrollPosition: true,
        shouldSort: true,
        shouldSortItems: false,
        sorter: utils_1.sortByAlpha,
        placeholder: true,
        placeholderValue: null,
        searchPlaceholderValue: null,
        prependValue: null,
        appendValue: null,
        renderSelectedChoices: 'auto',
        loadingText: 'Loading...',
        noResultsText: 'No results found',
        noChoicesText: 'No choices to choose from',
        itemSelectText: 'Press to select',
        uniqueItemText: 'Only unique values can be added',
        customAddItemText: 'Only values matching specific conditions can be added',
        addItemText: function addItemText(value) {
          return "Press Enter to add <b>\"" + utils_1.sanitise(value) + "\"</b>";
        },
        maxItemText: function maxItemText(maxItemCount) {
          return "Only " + maxItemCount + " values can be added";
        },
        valueComparer: function valueComparer(value1, value2) {
          return value1 === value2;
        },
        fuseOptions: {
          includeScore: true
        },
        callbackOnInit: null,
        callbackOnCreateTemplates: null,
        classNames: exports.DEFAULT_CLASSNAMES
      };
      exports.EVENTS = {
        showDropdown: 'showDropdown',
        hideDropdown: 'hideDropdown',
        change: 'change',
        choice: 'choice',
        search: 'search',
        addItem: 'addItem',
        removeItem: 'removeItem',
        highlightItem: 'highlightItem',
        highlightChoice: 'highlightChoice',
        unhighlightItem: 'unhighlightItem'
      };
      exports.ACTION_TYPES = {
        ADD_CHOICE: 'ADD_CHOICE',
        FILTER_CHOICES: 'FILTER_CHOICES',
        ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
        CLEAR_CHOICES: 'CLEAR_CHOICES',
        ADD_GROUP: 'ADD_GROUP',
        ADD_ITEM: 'ADD_ITEM',
        REMOVE_ITEM: 'REMOVE_ITEM',
        HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
        CLEAR_ALL: 'CLEAR_ALL',
        RESET_TO: 'RESET_TO',
        SET_IS_LOADING: 'SET_IS_LOADING'
      };
      exports.KEY_CODES = {
        BACK_KEY: 46,
        DELETE_KEY: 8,
        ENTER_KEY: 13,
        A_KEY: 65,
        ESC_KEY: 27,
        UP_KEY: 38,
        DOWN_KEY: 40,
        PAGE_UP_KEY: 33,
        PAGE_DOWN_KEY: 34
      };
      exports.TEXT_TYPE = 'text';
      exports.SELECT_ONE_TYPE = 'select-one';
      exports.SELECT_MULTIPLE_TYPE = 'select-multiple';
      exports.SCROLLING_SPEED = 4;

      /***/
    }),
/* 1 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      /* eslint-disable @typescript-eslint/no-explicit-any */

      exports.getRandomNumber = function (min, max) {
        return Math.floor(Math.random() * (max - min) + min);
      };

      exports.generateChars = function (length) {
        return Array.from({
          length: length
        }, function () {
          return exports.getRandomNumber(0, 36).toString(36);
        }).join('');
      };

      exports.generateId = function (element, prefix) {
        var id = element.id || element.name && element.name + "-" + exports.generateChars(2) || exports.generateChars(4);
        id = id.replace(/(:|\.|\[|\]|,)/g, '');
        id = prefix + "-" + id;
        return id;
      };

      exports.getType = function (obj) {
        return Object.prototype.toString.call(obj).slice(8, -1);
      };

      exports.isType = function (type, obj) {
        return obj !== undefined && obj !== null && exports.getType(obj) === type;
      };

      exports.wrap = function (element, wrapper) {
        if (wrapper === void 0) {
          wrapper = document.createElement('div');
        }

        if (element.nextSibling) {
          element.parentNode && element.parentNode.insertBefore(wrapper, element.nextSibling);
        } else {
          element.parentNode && element.parentNode.appendChild(wrapper);
        }

        return wrapper.appendChild(element);
      };

      exports.getAdjacentEl = function (startEl, selector, direction) {
        if (direction === void 0) {
          direction = 1;
        }

        var prop = (direction > 0 ? 'next' : 'previous') + "ElementSibling";
        var sibling = startEl[prop];

        while (sibling) {
          if (sibling.matches(selector)) {
            return sibling;
          }

          sibling = sibling[prop];
        }

        return sibling;
      };

      exports.isScrolledIntoView = function (element, parent, direction) {
        if (direction === void 0) {
          direction = 1;
        }

        if (!element) {
          return false;
        }

        var isVisible;

        if (direction > 0) {
          // In view from bottom
          isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
        } else {
          // In view from top
          isVisible = element.offsetTop >= parent.scrollTop;
        }

        return isVisible;
      };

      exports.sanitise = function (value) {
        if (typeof value !== 'string') {
          return value;
        }

        return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
      };

      exports.strToEl = function () {
        var tmpEl = document.createElement('div');
        return function (str) {
          var cleanedInput = str.trim();
          tmpEl.innerHTML = cleanedInput;
          var firldChild = tmpEl.children[0];

          while (tmpEl.firstChild) {
            tmpEl.removeChild(tmpEl.firstChild);
          }

          return firldChild;
        };
      }();

      exports.sortByAlpha = function (_a, _b) {
        var value = _a.value,
          _c = _a.label,
          label = _c === void 0 ? value : _c;
        var value2 = _b.value,
          _d = _b.label,
          label2 = _d === void 0 ? value2 : _d;
        return label.localeCompare(label2, [], {
          sensitivity: 'base',
          ignorePunctuation: true,
          numeric: true
        });
      };

      exports.sortByScore = function (a, b) {
        var _a = a.score,
          scoreA = _a === void 0 ? 0 : _a;
        var _b = b.score,
          scoreB = _b === void 0 ? 0 : _b;
        return scoreA - scoreB;
      };

      exports.dispatchEvent = function (element, type, customArgs) {
        if (customArgs === void 0) {
          customArgs = null;
        }

        var event = new CustomEvent(type, {
          detail: customArgs,
          bubbles: true,
          cancelable: true
        });
        return element.dispatchEvent(event);
      };

      exports.existsInArray = function (array, value, key) {
        if (key === void 0) {
          key = 'value';
        }

        return array.some(function (item) {
          if (typeof value === 'string') {
            return item[key] === value.trim();
          }

          return item[key] === value;
        });
      };

      exports.cloneObject = function (obj) {
        return JSON.parse(JSON.stringify(obj));
      };
      /**
       * Returns an array of keys present on the first but missing on the second object
       */


      exports.diff = function (a, b) {
        var aKeys = Object.keys(a).sort();
        var bKeys = Object.keys(b).sort();
        return aKeys.filter(function (i) {
          return bKeys.indexOf(i) < 0;
        });
      };

      /***/
    }),
/* 2 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
/* WEBPACK VAR INJECTION */(function (global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
        /* global window */


        var root;

        if (typeof self !== 'undefined') {
          root = self;
        } else if (typeof window !== 'undefined') {
          root = window;
        } else if (typeof global !== 'undefined') {
          root = global;
        } else if (true) {
          root = module;
        } else { }

        var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(root);
/* harmony default export */ __webpack_exports__["a"] = (result);

        /* WEBPACK VAR INJECTION */
      }.call(this, __webpack_require__(12), __webpack_require__(13)(module)))

      /***/
    }),
/* 3 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function () { return ActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function () { return applyMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function () { return bindActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function () { return combineReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function () { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function () { return createStore; });
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);


      /**
       * These are private action types reserved by Redux.
       * For any unknown actions, you must return the current state.
       * If the current state is undefined, you must return the initial state.
       * Do not reference these action types directly in your code.
       */
      var randomString = function randomString() {
        return Math.random().toString(36).substring(7).split('').join('.');
      };

      var ActionTypes = {
        INIT: "@@redux/INIT" + randomString(),
        REPLACE: "@@redux/REPLACE" + randomString(),
        PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
          return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
        }
      };

      /**
       * @param {any} obj The object to inspect.
       * @returns {boolean} True if the argument appears to be a plain object.
       */
      function isPlainObject(obj) {
        if (typeof obj !== 'object' || obj === null) return false;
        var proto = obj;

        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }

        return Object.getPrototypeOf(obj) === proto;
      }

      /**
       * Creates a Redux store that holds the state tree.
       * The only way to change the data in the store is to call `dispatch()` on it.
       *
       * There should only be a single store in your app. To specify how different
       * parts of the state tree respond to actions, you may combine several reducers
       * into a single reducer function by using `combineReducers`.
       *
       * @param {Function} reducer A function that returns the next state tree, given
       * the current state tree and the action to handle.
       *
       * @param {any} [preloadedState] The initial state. You may optionally specify it
       * to hydrate the state from the server in universal apps, or to restore a
       * previously serialized user session.
       * If you use `combineReducers` to produce the root reducer function, this must be
       * an object with the same shape as `combineReducers` keys.
       *
       * @param {Function} [enhancer] The store enhancer. You may optionally specify it
       * to enhance the store with third-party capabilities such as middleware,
       * time travel, persistence, etc. The only store enhancer that ships with Redux
       * is `applyMiddleware()`.
       *
       * @returns {Store} A Redux store that lets you read the state, dispatch actions
       * and subscribe to changes.
       */

      function createStore(reducer, preloadedState, enhancer) {
        var _ref2;

        if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
          throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
        }

        if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
          enhancer = preloadedState;
          preloadedState = undefined;
        }

        if (typeof enhancer !== 'undefined') {
          if (typeof enhancer !== 'function') {
            throw new Error('Expected the enhancer to be a function.');
          }

          return enhancer(createStore)(reducer, preloadedState);
        }

        if (typeof reducer !== 'function') {
          throw new Error('Expected the reducer to be a function.');
        }

        var currentReducer = reducer;
        var currentState = preloadedState;
        var currentListeners = [];
        var nextListeners = currentListeners;
        var isDispatching = false;
        /**
         * This makes a shallow copy of currentListeners so we can use
         * nextListeners as a temporary list while dispatching.
         *
         * This prevents any bugs around consumers calling
         * subscribe/unsubscribe in the middle of a dispatch.
         */

        function ensureCanMutateNextListeners() {
          if (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice();
          }
        }
        /**
         * Reads the state tree managed by the store.
         *
         * @returns {any} The current state tree of your application.
         */


        function getState() {
          if (isDispatching) {
            throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
          }

          return currentState;
        }
        /**
         * Adds a change listener. It will be called any time an action is dispatched,
         * and some part of the state tree may potentially have changed. You may then
         * call `getState()` to read the current state tree inside the callback.
         *
         * You may call `dispatch()` from a change listener, with the following
         * caveats:
         *
         * 1. The subscriptions are snapshotted just before every `dispatch()` call.
         * If you subscribe or unsubscribe while the listeners are being invoked, this
         * will not have any effect on the `dispatch()` that is currently in progress.
         * However, the next `dispatch()` call, whether nested or not, will use a more
         * recent snapshot of the subscription list.
         *
         * 2. The listener should not expect to see all state changes, as the state
         * might have been updated multiple times during a nested `dispatch()` before
         * the listener is called. It is, however, guaranteed that all subscribers
         * registered before the `dispatch()` started will be called with the latest
         * state by the time it exits.
         *
         * @param {Function} listener A callback to be invoked on every dispatch.
         * @returns {Function} A function to remove this change listener.
         */


        function subscribe(listener) {
          if (typeof listener !== 'function') {
            throw new Error('Expected the listener to be a function.');
          }

          if (isDispatching) {
            throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
          }

          var isSubscribed = true;
          ensureCanMutateNextListeners();
          nextListeners.push(listener);
          return function unsubscribe() {
            if (!isSubscribed) {
              return;
            }

            if (isDispatching) {
              throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
            }

            isSubscribed = false;
            ensureCanMutateNextListeners();
            var index = nextListeners.indexOf(listener);
            nextListeners.splice(index, 1);
          };
        }
        /**
         * Dispatches an action. It is the only way to trigger a state change.
         *
         * The `reducer` function, used to create the store, will be called with the
         * current state tree and the given `action`. Its return value will
         * be considered the **next** state of the tree, and the change listeners
         * will be notified.
         *
         * The base implementation only supports plain object actions. If you want to
         * dispatch a Promise, an Observable, a thunk, or something else, you need to
         * wrap your store creating function into the corresponding middleware. For
         * example, see the documentation for the `redux-thunk` package. Even the
         * middleware will eventually dispatch plain object actions using this method.
         *
         * @param {Object} action A plain object representing âwhat changedâ. It is
         * a good idea to keep actions serializable so you can record and replay user
         * sessions, or use the time travelling `redux-devtools`. An action must have
         * a `type` property which may not be `undefined`. It is a good idea to use
         * string constants for action types.
         *
         * @returns {Object} For convenience, the same action object you dispatched.
         *
         * Note that, if you use a custom middleware, it may wrap `dispatch()` to
         * return something else (for example, a Promise you can await).
         */


        function dispatch(action) {
          if (!isPlainObject(action)) {
            throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
          }

          if (typeof action.type === 'undefined') {
            throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
          }

          if (isDispatching) {
            throw new Error('Reducers may not dispatch actions.');
          }

          try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
          } finally {
            isDispatching = false;
          }

          var listeners = currentListeners = nextListeners;

          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            listener();
          }

          return action;
        }
        /**
         * Replaces the reducer currently used by the store to calculate the state.
         *
         * You might need this if your app implements code splitting and you want to
         * load some of the reducers dynamically. You might also need this if you
         * implement a hot reloading mechanism for Redux.
         *
         * @param {Function} nextReducer The reducer for the store to use instead.
         * @returns {void}
         */


        function replaceReducer(nextReducer) {
          if (typeof nextReducer !== 'function') {
            throw new Error('Expected the nextReducer to be a function.');
          }

          currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
          // Any reducers that existed in both the new and old rootReducer
          // will receive the previous state. This effectively populates
          // the new state tree with any relevant data from the old one.

          dispatch({
            type: ActionTypes.REPLACE
          });
        }
        /**
         * Interoperability point for observable/reactive libraries.
         * @returns {observable} A minimal observable of state changes.
         * For more information, see the observable proposal:
         * https://github.com/tc39/proposal-observable
         */


        function observable() {
          var _ref;

          var outerSubscribe = subscribe;
          return _ref = {
            /**
             * The minimal observable subscription method.
             * @param {Object} observer Any object that can be used as an observer.
             * The observer object should have a `next` method.
             * @returns {subscription} An object with an `unsubscribe` method that can
             * be used to unsubscribe the observable from the store, and prevent further
             * emission of values from the observable.
             */
            subscribe: function subscribe(observer) {
              if (typeof observer !== 'object' || observer === null) {
                throw new TypeError('Expected the observer to be an object.');
              }

              function observeState() {
                if (observer.next) {
                  observer.next(getState());
                }
              }

              observeState();
              var unsubscribe = outerSubscribe(observeState);
              return {
                unsubscribe: unsubscribe
              };
            }
          }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]] = function () {
            return this;
          }, _ref;
        } // When a store is created, an "INIT" action is dispatched so that every
        // reducer returns their initial state. This effectively populates
        // the initial state tree.


        dispatch({
          type: ActionTypes.INIT
        });
        return _ref2 = {
          dispatch: dispatch,
          subscribe: subscribe,
          getState: getState,
          replaceReducer: replaceReducer
        }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]] = observable, _ref2;
      }

      /**
       * Prints a warning in the console if it exists.
       *
       * @param {String} message The warning message.
       * @returns {void}
       */
      function warning(message) {
        /* eslint-disable no-console */
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          console.error(message);
        }
        /* eslint-enable no-console */


        try {
          // This error was thrown as a convenience so that if you enable
          // "break on all exceptions" in your console,
          // it would pause the execution at this line.
          throw new Error(message);
        } catch (e) { } // eslint-disable-line no-empty

      }

      function getUndefinedStateErrorMessage(key, action) {
        var actionType = action && action.type;
        var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
        return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
      }

      function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
        var reducerKeys = Object.keys(reducers);
        var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

        if (reducerKeys.length === 0) {
          return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
        }

        if (!isPlainObject(inputState)) {
          return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
        }

        var unexpectedKeys = Object.keys(inputState).filter(function (key) {
          return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
        });
        unexpectedKeys.forEach(function (key) {
          unexpectedKeyCache[key] = true;
        });
        if (action && action.type === ActionTypes.REPLACE) return;

        if (unexpectedKeys.length > 0) {
          return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
        }
      }

      function assertReducerShape(reducers) {
        Object.keys(reducers).forEach(function (key) {
          var reducer = reducers[key];
          var initialState = reducer(undefined, {
            type: ActionTypes.INIT
          });

          if (typeof initialState === 'undefined') {
            throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
          }

          if (typeof reducer(undefined, {
            type: ActionTypes.PROBE_UNKNOWN_ACTION()
          }) === 'undefined') {
            throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
          }
        });
      }
      /**
       * Turns an object whose values are different reducer functions, into a single
       * reducer function. It will call every child reducer, and gather their results
       * into a single state object, whose keys correspond to the keys of the passed
       * reducer functions.
       *
       * @param {Object} reducers An object whose values correspond to different
       * reducer functions that need to be combined into one. One handy way to obtain
       * it is to use ES6 `import * as reducers` syntax. The reducers may never return
       * undefined for any action. Instead, they should return their initial state
       * if the state passed to them was undefined, and the current state for any
       * unrecognized action.
       *
       * @returns {Function} A reducer function that invokes every reducer inside the
       * passed object, and builds a state object with the same shape.
       */


      function combineReducers(reducers) {
        var reducerKeys = Object.keys(reducers);
        var finalReducers = {};

        for (var i = 0; i < reducerKeys.length; i++) {
          var key = reducerKeys[i];

          if (false) { }

          if (typeof reducers[key] === 'function') {
            finalReducers[key] = reducers[key];
          }
        }

        var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
        // keys multiple times.

        var unexpectedKeyCache;

        if (false) { }

        var shapeAssertionError;

        try {
          assertReducerShape(finalReducers);
        } catch (e) {
          shapeAssertionError = e;
        }

        return function combination(state, action) {
          if (state === void 0) {
            state = {};
          }

          if (shapeAssertionError) {
            throw shapeAssertionError;
          }

          if (false) { var warningMessage; }

          var hasChanged = false;
          var nextState = {};

          for (var _i = 0; _i < finalReducerKeys.length; _i++) {
            var _key = finalReducerKeys[_i];
            var reducer = finalReducers[_key];
            var previousStateForKey = state[_key];
            var nextStateForKey = reducer(previousStateForKey, action);

            if (typeof nextStateForKey === 'undefined') {
              var errorMessage = getUndefinedStateErrorMessage(_key, action);
              throw new Error(errorMessage);
            }

            nextState[_key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
          }

          return hasChanged ? nextState : state;
        };
      }

      function bindActionCreator(actionCreator, dispatch) {
        return function () {
          return dispatch(actionCreator.apply(this, arguments));
        };
      }
      /**
       * Turns an object whose values are action creators, into an object with the
       * same keys, but with every function wrapped into a `dispatch` call so they
       * may be invoked directly. This is just a convenience method, as you can call
       * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
       *
       * For convenience, you can also pass an action creator as the first argument,
       * and get a dispatch wrapped function in return.
       *
       * @param {Function|Object} actionCreators An object whose values are action
       * creator functions. One handy way to obtain it is to use ES6 `import * as`
       * syntax. You may also pass a single function.
       *
       * @param {Function} dispatch The `dispatch` function available on your Redux
       * store.
       *
       * @returns {Function|Object} The object mimicking the original object, but with
       * every action creator wrapped into the `dispatch` call. If you passed a
       * function as `actionCreators`, the return value will also be a single
       * function.
       */


      function bindActionCreators(actionCreators, dispatch) {
        if (typeof actionCreators === 'function') {
          return bindActionCreator(actionCreators, dispatch);
        }

        if (typeof actionCreators !== 'object' || actionCreators === null) {
          throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
        }

        var boundActionCreators = {};

        for (var key in actionCreators) {
          var actionCreator = actionCreators[key];

          if (typeof actionCreator === 'function') {
            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
          }
        }

        return boundActionCreators;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          keys.push.apply(keys, Object.getOwnPropertySymbols(object));
        }

        if (enumerableOnly) keys = keys.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        return keys;
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(source, true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(source).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      /**
       * Composes single-argument functions from right to left. The rightmost
       * function can take multiple arguments as it provides the signature for
       * the resulting composite function.
       *
       * @param {...Function} funcs The functions to compose.
       * @returns {Function} A function obtained by composing the argument functions
       * from right to left. For example, compose(f, g, h) is identical to doing
       * (...args) => f(g(h(...args))).
       */
      function compose() {
        for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
          funcs[_key] = arguments[_key];
        }

        if (funcs.length === 0) {
          return function (arg) {
            return arg;
          };
        }

        if (funcs.length === 1) {
          return funcs[0];
        }

        return funcs.reduce(function (a, b) {
          return function () {
            return a(b.apply(void 0, arguments));
          };
        });
      }

      /**
       * Creates a store enhancer that applies middleware to the dispatch method
       * of the Redux store. This is handy for a variety of tasks, such as expressing
       * asynchronous actions in a concise manner, or logging every action payload.
       *
       * See `redux-thunk` package as an example of the Redux middleware.
       *
       * Because middleware is potentially asynchronous, this should be the first
       * store enhancer in the composition chain.
       *
       * Note that each middleware will be given the `dispatch` and `getState` functions
       * as named arguments.
       *
       * @param {...Function} middlewares The middleware chain to be applied.
       * @returns {Function} A store enhancer applying the middleware.
       */

      function applyMiddleware() {
        for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
          middlewares[_key] = arguments[_key];
        }

        return function (createStore) {
          return function () {
            var store = createStore.apply(void 0, arguments);

            var _dispatch = function dispatch() {
              throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
            };

            var middlewareAPI = {
              getState: store.getState,
              dispatch: function dispatch() {
                return _dispatch.apply(void 0, arguments);
              }
            };
            var chain = middlewares.map(function (middleware) {
              return middleware(middlewareAPI);
            });
            _dispatch = compose.apply(void 0, chain)(store.dispatch);
            return _objectSpread2({}, store, {
              dispatch: _dispatch
            });
          };
        };
      }

      /*
       * This is a dummy function to check if the function name has been altered by minification.
       * If the function has been minified and NODE_ENV !== 'production', warn the user.
       */

      function isCrushed() { }

      if (false) { }




      /***/
    }),
/* 4 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var redux_1 = __webpack_require__(3);

      var items_1 = __importDefault(__webpack_require__(14));

      var groups_1 = __importDefault(__webpack_require__(15));

      var choices_1 = __importDefault(__webpack_require__(16));

      var loading_1 = __importDefault(__webpack_require__(17));

      var utils_1 = __webpack_require__(1);

      exports.defaultState = {
        groups: [],
        items: [],
        choices: [],
        loading: false
      };
      var appReducer = redux_1.combineReducers({
        items: items_1.default,
        groups: groups_1.default,
        choices: choices_1.default,
        loading: loading_1.default
      });

      var rootReducer = function rootReducer(passedState, action) {
        var state = passedState; // If we are clearing all items, groups and options we reassign
        // state and then pass that state to our proper reducer. This isn't
        // mutating our actual state
        // See: http://stackoverflow.com/a/35641992

        if (action.type === 'CLEAR_ALL') {
          state = exports.defaultState;
        } else if (action.type === 'RESET_TO') {
          return utils_1.cloneObject(action.state);
        }

        return appReducer(state, action);
      };

      exports.default = rootReducer;

      /***/
    }),
/* 5 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var utils_1 = __webpack_require__(1);

      var WrappedElement =
        /** @class */
        function () {
          function WrappedElement(_a) {
            var element = _a.element,
              classNames = _a.classNames;
            this.element = element;
            this.classNames = classNames;

            if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
              throw new TypeError('Invalid element passed');
            }

            this.isDisabled = false;
          }

          Object.defineProperty(WrappedElement.prototype, "isActive", {
            get: function get() {
              return this.element.dataset.choice === 'active';
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(WrappedElement.prototype, "dir", {
            get: function get() {
              return this.element.dir;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(WrappedElement.prototype, "value", {
            get: function get() {
              return this.element.value;
            },
            set: function set(value) {
              // you must define setter here otherwise it will be readonly property
              this.element.value = value;
            },
            enumerable: true,
            configurable: true
          });

          WrappedElement.prototype.conceal = function () {
            // Hide passed input
            this.element.classList.add(this.classNames.input);
            this.element.hidden = true; // Remove element from tab index

            this.element.tabIndex = -1; // Backup original styles if any

            var origStyle = this.element.getAttribute('style');

            if (origStyle) {
              this.element.setAttribute('data-choice-orig-style', origStyle);
            }

            this.element.setAttribute('data-choice', 'active');
          };

          WrappedElement.prototype.reveal = function () {
            // Reinstate passed element
            this.element.classList.remove(this.classNames.input);
            this.element.hidden = false;
            this.element.removeAttribute('tabindex'); // Recover original styles if any

            var origStyle = this.element.getAttribute('data-choice-orig-style');

            if (origStyle) {
              this.element.removeAttribute('data-choice-orig-style');
              this.element.setAttribute('style', origStyle);
            } else {
              this.element.removeAttribute('style');
            }

            this.element.removeAttribute('data-choice'); // Re-assign values - this is weird, I know
            // @todo Figure out why we need to do this

            this.element.value = this.element.value; // eslint-disable-line no-self-assign
          };

          WrappedElement.prototype.enable = function () {
            this.element.removeAttribute('disabled');
            this.element.disabled = false;
            this.isDisabled = false;
          };

          WrappedElement.prototype.disable = function () {
            this.element.setAttribute('disabled', '');
            this.element.disabled = true;
            this.isDisabled = true;
          };

          WrappedElement.prototype.triggerEvent = function (eventType, data) {
            utils_1.dispatchEvent(this.element, eventType, data);
          };

          return WrappedElement;
        }();

      exports.default = WrappedElement;

      /***/
    }),
/* 6 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function () { return symbolObservablePonyfill; });
      function symbolObservablePonyfill(root) {
        var result;
        var Symbol = root.Symbol;

        if (typeof Symbol === 'function') {
          if (Symbol.observable) {
            result = Symbol.observable;
          } else {
            result = Symbol('observable');
            Symbol.observable = result;
          }
        } else {
          result = '@@observable';
        }

        return result;
      };


      /***/
    }),
/* 7 */
/***/ (function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(8);


      /***/
    }),
/* 8 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __spreadArrays = this && this.__spreadArrays || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
          s += arguments[i].length;
        }

        for (var r = Array(s), k = 0, i = 0; i < il; i++) {
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }

        return r;
      };

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      /* eslint-disable @typescript-eslint/no-explicit-any */

      var fuse_js_1 = __importDefault(__webpack_require__(9));

      var deepmerge_1 = __importDefault(__webpack_require__(10));

      var store_1 = __importDefault(__webpack_require__(11));

      var components_1 = __webpack_require__(18);

      var constants_1 = __webpack_require__(0);

      var templates_1 = __importDefault(__webpack_require__(25));

      var choices_1 = __webpack_require__(26);

      var items_1 = __webpack_require__(27);

      var groups_1 = __webpack_require__(28);

      var misc_1 = __webpack_require__(29);

      var utils_1 = __webpack_require__(1);

      var reducers_1 = __webpack_require__(4);
      /** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */


      var IS_IE11 = '-ms-scroll-limit' in document.documentElement.style && '-ms-ime-align' in document.documentElement.style;
      var USER_DEFAULTS = {};
      /**
       * Choices
       * @author Josh Johnson<josh@joshuajohnson.co.uk>
       */

      var Choices =
        /** @class */
        function () {
          function Choices(element, userConfig) {
            var _this = this;

            if (element === void 0) {
              element = '[data-choice]';
            }

            if (userConfig === void 0) {
              userConfig = {};
            }

            this.config = deepmerge_1.default.all([constants_1.DEFAULT_CONFIG, Choices.defaults.options, userConfig], // When merging array configs, replace with a copy of the userConfig array,
              // instead of concatenating with the default array
              {
                arrayMerge: function arrayMerge(_, sourceArray) {
                  return __spreadArrays(sourceArray);
                }
              });
            var invalidConfigOptions = utils_1.diff(this.config, constants_1.DEFAULT_CONFIG);

            if (invalidConfigOptions.length) {
              console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
            }

            var passedElement = typeof element === 'string' ? document.querySelector(element) : element;

            if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
              throw TypeError('Expected one of the following types text|select-one|select-multiple');
            }

            this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
            this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
            this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
            this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
            this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;

            if (!['auto', 'always'].includes("" + this.config.renderSelectedChoices)) {
              this.config.renderSelectedChoices = 'auto';
            }

            if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {
              var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
              this.config.addItemFilter = re.test.bind(re);
            }

            if (this._isTextElement) {
              this.passedElement = new components_1.WrappedInput({
                element: passedElement,
                classNames: this.config.classNames,
                delimiter: this.config.delimiter
              });
            } else {
              this.passedElement = new components_1.WrappedSelect({
                element: passedElement,
                classNames: this.config.classNames,
                template: function template(data) {
                  return _this._templates.option(data);
                }
              });
            }

            this.initialised = false;
            this._store = new store_1.default();
            this._initialState = reducers_1.defaultState;
            this._currentState = reducers_1.defaultState;
            this._prevState = reducers_1.defaultState;
            this._currentValue = '';
            this._canSearch = !!this.config.searchEnabled;
            this._isScrollingOnIe = false;
            this._highlightPosition = 0;
            this._wasTap = true;
            this._placeholderValue = this._generatePlaceholderValue();
            this._baseId = utils_1.generateId(this.passedElement.element, 'choices-');
            /**
             * setting direction in cases where it's explicitly set on passedElement
             * or when calculated direction is different from the document
             */

            this._direction = this.passedElement.dir;

            if (!this._direction) {
              var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
              var documentDirection = window.getComputedStyle(document.documentElement).direction;

              if (elementDirection !== documentDirection) {
                this._direction = elementDirection;
              }
            }

            this._idNames = {
              itemChoice: 'item-choice'
            };

            if (this._isSelectElement) {
              // Assign preset groups from passed element
              this._presetGroups = this.passedElement.optionGroups; // Assign preset options from passed element

              this._presetOptions = this.passedElement.options;
            } // Assign preset choices from passed object


            this._presetChoices = this.config.choices; // Assign preset items from passed object first

            this._presetItems = this.config.items; // Add any values passed from attribute

            if (this.passedElement.value && this._isTextElement) {
              var splitValues = this.passedElement.value.split(this.config.delimiter);
              this._presetItems = this._presetItems.concat(splitValues);
            } // Create array of choices from option elements


            if (this.passedElement.options) {
              this.passedElement.options.forEach(function (option) {
                _this._presetChoices.push({
                  value: option.value,
                  label: option.innerHTML,
                  selected: !!option.selected,
                  disabled: option.disabled || option.parentNode.disabled,
                  placeholder: option.value === '' || option.hasAttribute('placeholder'),
                  customProperties: option.dataset['custom-properties']
                });
              });
            }

            this._render = this._render.bind(this);
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
            this._onKeyUp = this._onKeyUp.bind(this);
            this._onKeyDown = this._onKeyDown.bind(this);
            this._onClick = this._onClick.bind(this);
            this._onTouchMove = this._onTouchMove.bind(this);
            this._onTouchEnd = this._onTouchEnd.bind(this);
            this._onMouseDown = this._onMouseDown.bind(this);
            this._onMouseOver = this._onMouseOver.bind(this);
            this._onFormReset = this._onFormReset.bind(this);
            this._onSelectKey = this._onSelectKey.bind(this);
            this._onEnterKey = this._onEnterKey.bind(this);
            this._onEscapeKey = this._onEscapeKey.bind(this);
            this._onDirectionKey = this._onDirectionKey.bind(this);
            this._onDeleteKey = this._onDeleteKey.bind(this); // If element has already been initialised with Choices, fail silently

            if (this.passedElement.isActive) {
              if (!this.config.silent) {
                console.warn('Trying to initialise Choices on element already initialised', {
                  element: element
                });
              }

              this.initialised = true;
              return;
            } // Let's go


            this.init();
          }

          Object.defineProperty(Choices, "defaults", {
            get: function get() {
              return Object.preventExtensions({
                get options() {
                  return USER_DEFAULTS;
                },

                get templates() {
                  return templates_1.default;
                }

              });
            },
            enumerable: true,
            configurable: true
          });

          Choices.prototype.init = function () {
            if (this.initialised) {
              return;
            }

            this._createTemplates();

            this._createElements();

            this._createStructure();

            this._store.subscribe(this._render);

            this._render();

            this._addEventListeners();

            var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute('disabled');

            if (shouldDisable) {
              this.disable();
            }

            this.initialised = true;
            var callbackOnInit = this.config.callbackOnInit; // Run callback if it is a function

            if (callbackOnInit && typeof callbackOnInit === 'function') {
              callbackOnInit.call(this);
            }
          };

          Choices.prototype.destroy = function () {
            if (!this.initialised) {
              return;
            }

            this._removeEventListeners();

            this.passedElement.reveal();
            this.containerOuter.unwrap(this.passedElement.element);
            this.clearStore();

            if (this._isSelectElement) {
              this.passedElement.options = this._presetOptions;
            }

            this._templates = templates_1.default;
            this.initialised = false;
          };

          Choices.prototype.enable = function () {
            if (this.passedElement.isDisabled) {
              this.passedElement.enable();
            }

            if (this.containerOuter.isDisabled) {
              this._addEventListeners();

              this.input.enable();
              this.containerOuter.enable();
            }

            return this;
          };

          Choices.prototype.disable = function () {
            if (!this.passedElement.isDisabled) {
              this.passedElement.disable();
            }

            if (!this.containerOuter.isDisabled) {
              this._removeEventListeners();

              this.input.disable();
              this.containerOuter.disable();
            }

            return this;
          };

          Choices.prototype.highlightItem = function (item, runEvent) {
            if (runEvent === void 0) {
              runEvent = true;
            }

            if (!item || !item.id) {
              return this;
            }

            var id = item.id,
              _a = item.groupId,
              groupId = _a === void 0 ? -1 : _a,
              _b = item.value,
              value = _b === void 0 ? '' : _b,
              _c = item.label,
              label = _c === void 0 ? '' : _c;
            var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

            this._store.dispatch(items_1.highlightItem(id, true));

            if (runEvent) {
              this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                id: id,
                value: value,
                label: label,
                groupValue: group && group.value ? group.value : null
              });
            }

            return this;
          };

          Choices.prototype.unhighlightItem = function (item) {
            if (!item || !item.id) {
              return this;
            }

            var id = item.id,
              _a = item.groupId,
              groupId = _a === void 0 ? -1 : _a,
              _b = item.value,
              value = _b === void 0 ? '' : _b,
              _c = item.label,
              label = _c === void 0 ? '' : _c;
            var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

            this._store.dispatch(items_1.highlightItem(id, false));

            this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
              id: id,
              value: value,
              label: label,
              groupValue: group && group.value ? group.value : null
            });
            return this;
          };

          Choices.prototype.highlightAll = function () {
            var _this = this;

            this._store.items.forEach(function (item) {
              return _this.highlightItem(item);
            });

            return this;
          };

          Choices.prototype.unhighlightAll = function () {
            var _this = this;

            this._store.items.forEach(function (item) {
              return _this.unhighlightItem(item);
            });

            return this;
          };

          Choices.prototype.removeActiveItemsByValue = function (value) {
            var _this = this;

            this._store.activeItems.filter(function (item) {
              return item.value === value;
            }).forEach(function (item) {
              return _this._removeItem(item);
            });

            return this;
          };

          Choices.prototype.removeActiveItems = function (excludedId) {
            var _this = this;

            this._store.activeItems.filter(function (_a) {
              var id = _a.id;
              return id !== excludedId;
            }).forEach(function (item) {
              return _this._removeItem(item);
            });

            return this;
          };

          Choices.prototype.removeHighlightedItems = function (runEvent) {
            var _this = this;

            if (runEvent === void 0) {
              runEvent = false;
            }

            this._store.highlightedActiveItems.forEach(function (item) {
              _this._removeItem(item); // If this action was performed by the user
              // trigger the event


              if (runEvent) {
                _this._triggerChange(item.value);
              }
            });

            return this;
          };

          Choices.prototype.showDropdown = function (preventInputFocus) {
            var _this = this;

            if (this.dropdown.isActive) {
              return this;
            }

            requestAnimationFrame(function () {
              _this.dropdown.show();

              _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);

              if (!preventInputFocus && _this._canSearch) {
                _this.input.focus();
              }

              _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
            });
            return this;
          };

          Choices.prototype.hideDropdown = function (preventInputBlur) {
            var _this = this;

            if (!this.dropdown.isActive) {
              return this;
            }

            requestAnimationFrame(function () {
              _this.dropdown.hide();

              _this.containerOuter.close();

              if (!preventInputBlur && _this._canSearch) {
                _this.input.removeActiveDescendant();

                _this.input.blur();
              }

              _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
            });
            return this;
          };

          Choices.prototype.getValue = function (valueOnly) {
            if (valueOnly === void 0) {
              valueOnly = false;
            }

            var values = this._store.activeItems.reduce(function (selectedItems, item) {
              var itemValue = valueOnly ? item.value : item;
              selectedItems.push(itemValue);
              return selectedItems;
            }, []);

            return this._isSelectOneElement ? values[0] : values;
          };

          Choices.prototype.setValue = function (items) {
            var _this = this;

            if (!this.initialised) {
              return this;
            }

            items.forEach(function (value) {
              return _this._setChoiceOrItem(value);
            });
            return this;
          };

          Choices.prototype.setChoiceByValue = function (value) {
            var _this = this;

            if (!this.initialised || this._isTextElement) {
              return this;
            } // If only one value has been passed, convert to array


            var choiceValue = Array.isArray(value) ? value : [value]; // Loop through each value and

            choiceValue.forEach(function (val) {
              return _this._findAndSelectChoiceByValue(val);
            });
            return this;
          };
          /**
           * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
           * a value field name and a label field name.
           * This behaves the same as passing items via the choices option but can be called after initialising Choices.
           * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
           * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
           *
           * **Input types affected:** select-one, select-multiple
           *
           * @example
           * ```js
           * const example = new Choices(element);
           *
           * example.setChoices([
           *   {value: 'One', label: 'Label One', disabled: true},
           *   {value: 'Two', label: 'Label Two', selected: true},
           *   {value: 'Three', label: 'Label Three'},
           * ], 'value', 'label', false);
           * ```
           *
           * @example
           * ```js
           * const example = new Choices(element);
           *
           * example.setChoices(async () => {
           *   try {
           *      const items = await fetch('/items');
           *      return items.json()
           *   } catch(err) {
           *      console.error(err)
           *   }
           * });
           * ```
           *
           * @example
           * ```js
           * const example = new Choices(element);
           *
           * example.setChoices([{
           *   label: 'Group one',
           *   id: 1,
           *   disabled: false,
           *   choices: [
           *     {value: 'Child One', label: 'Child One', selected: true},
           *     {value: 'Child Two', label: 'Child Two',  disabled: true},
           *     {value: 'Child Three', label: 'Child Three'},
           *   ]
           * },
           * {
           *   label: 'Group two',
           *   id: 2,
           *   disabled: false,
           *   choices: [
           *     {value: 'Child Four', label: 'Child Four', disabled: true},
           *     {value: 'Child Five', label: 'Child Five'},
           *     {value: 'Child Six', label: 'Child Six', customProperties: {
           *       description: 'Custom description about child six',
           *       random: 'Another random custom property'
           *     }},
           *   ]
           * }], 'value', 'label', false);
           * ```
           */


          Choices.prototype.setChoices = function (choicesArrayOrFetcher, value, label, replaceChoices) {
            var _this = this;

            if (choicesArrayOrFetcher === void 0) {
              choicesArrayOrFetcher = [];
            }

            if (value === void 0) {
              value = 'value';
            }

            if (label === void 0) {
              label = 'label';
            }

            if (replaceChoices === void 0) {
              replaceChoices = false;
            }

            if (!this.initialised) {
              throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
            }

            if (!this._isSelectElement) {
              throw new TypeError("setChoices can't be used with INPUT based Choices");
            }

            if (typeof value !== 'string' || !value) {
              throw new TypeError("value parameter must be a name of 'value' field in passed objects");
            } // Clear choices if needed


            if (replaceChoices) {
              this.clearChoices();
            }

            if (typeof choicesArrayOrFetcher === 'function') {
              // it's a choices fetcher function
              var fetcher_1 = choicesArrayOrFetcher(this);

              if (typeof Promise === 'function' && fetcher_1 instanceof Promise) {
                // that's a promise
                // eslint-disable-next-line compat/compat
                return new Promise(function (resolve) {
                  return requestAnimationFrame(resolve);
                }) // eslint-disable-line compat/compat
                  .then(function () {
                    return _this._handleLoadingState(true);
                  }).then(function () {
                    return fetcher_1;
                  }).then(function (data) {
                    return _this.setChoices(data, value, label, replaceChoices);
                  }).catch(function (err) {
                    if (!_this.config.silent) {
                      console.error(err);
                    }
                  }).then(function () {
                    return _this._handleLoadingState(false);
                  }).then(function () {
                    return _this;
                  });
              } // function returned something else than promise, let's check if it's an array of choices


              if (!Array.isArray(fetcher_1)) {
                throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: " + typeof fetcher_1);
              } // recursion with results, it's sync and choices were cleared already


              return this.setChoices(fetcher_1, value, label, false);
            }

            if (!Array.isArray(choicesArrayOrFetcher)) {
              throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
            }

            this.containerOuter.removeLoadingState();

            this._startLoading();

            choicesArrayOrFetcher.forEach(function (groupOrChoice) {
              if (groupOrChoice.choices) {
                _this._addGroup({
                  id: groupOrChoice.id ? parseInt("" + groupOrChoice.id, 10) : null,
                  group: groupOrChoice,
                  valueKey: value,
                  labelKey: label
                });
              } else {
                var choice = groupOrChoice;

                _this._addChoice({
                  value: choice[value],
                  label: choice[label],
                  isSelected: !!choice.selected,
                  isDisabled: !!choice.disabled,
                  placeholder: !!choice.placeholder,
                  customProperties: choice.customProperties
                });
              }
            });

            this._stopLoading();

            return this;
          };

          Choices.prototype.clearChoices = function () {
            this._store.dispatch(choices_1.clearChoices());

            return this;
          };

          Choices.prototype.clearStore = function () {
            this._store.dispatch(misc_1.clearAll());

            return this;
          };

          Choices.prototype.clearInput = function () {
            var shouldSetInputWidth = !this._isSelectOneElement;
            this.input.clear(shouldSetInputWidth);

            if (!this._isTextElement && this._canSearch) {
              this._isSearching = false;

              this._store.dispatch(choices_1.activateChoices(true));
            }

            return this;
          };

          Choices.prototype._render = function () {
            if (this._store.isLoading()) {
              return;
            }

            this._currentState = this._store.state;
            var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
            var shouldRenderChoices = this._isSelectElement;
            var shouldRenderItems = this._currentState.items !== this._prevState.items;

            if (!stateChanged) {
              return;
            }

            if (shouldRenderChoices) {
              this._renderChoices();
            }

            if (shouldRenderItems) {
              this._renderItems();
            }

            this._prevState = this._currentState;
          };

          Choices.prototype._renderChoices = function () {
            var _this = this;

            var _a = this._store,
              activeGroups = _a.activeGroups,
              activeChoices = _a.activeChoices;
            var choiceListFragment = document.createDocumentFragment();
            this.choiceList.clear();

            if (this.config.resetScrollPosition) {
              requestAnimationFrame(function () {
                return _this.choiceList.scrollToTop();
              });
            } // If we have grouped options


            if (activeGroups.length >= 1 && !this._isSearching) {
              // If we have a placeholder choice along with groups
              var activePlaceholders = activeChoices.filter(function (activeChoice) {
                return activeChoice.placeholder === true && activeChoice.groupId === -1;
              });

              if (activePlaceholders.length >= 1) {
                choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
              }

              choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
            } else if (activeChoices.length >= 1) {
              choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
            } // If we have choices to show


            if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
              var activeItems = this._store.activeItems;

              var canAddItem = this._canAddItem(activeItems, this.input.value); // ...and we can select them


              if (canAddItem.response) {
                // ...append them and highlight the first choice
                this.choiceList.append(choiceListFragment);

                this._highlightChoice();
              } else {
                var notice = this._getTemplate('notice', canAddItem.notice);

                this.choiceList.append(notice);
              }
            } else {
              // Otherwise show a notice
              var dropdownItem = void 0;
              var notice = void 0;

              if (this._isSearching) {
                notice = typeof this.config.noResultsText === 'function' ? this.config.noResultsText() : this.config.noResultsText;
                dropdownItem = this._getTemplate('notice', notice, 'no-results');
              } else {
                notice = typeof this.config.noChoicesText === 'function' ? this.config.noChoicesText() : this.config.noChoicesText;
                dropdownItem = this._getTemplate('notice', notice, 'no-choices');
              }

              this.choiceList.append(dropdownItem);
            }
          };

          Choices.prototype._renderItems = function () {
            var activeItems = this._store.activeItems || [];
            this.itemList.clear(); // Create a fragment to store our list items
            // (so we don't have to update the DOM for each item)

            var itemListFragment = this._createItemsFragment(activeItems); // If we have items to add, append them


            if (itemListFragment.childNodes) {
              this.itemList.append(itemListFragment);
            }
          };

          Choices.prototype._createGroupsFragment = function (groups, choices, fragment) {
            var _this = this;

            if (fragment === void 0) {
              fragment = document.createDocumentFragment();
            }

            var getGroupChoices = function getGroupChoices(group) {
              return choices.filter(function (choice) {
                if (_this._isSelectOneElement) {
                  return choice.groupId === group.id;
                }

                return choice.groupId === group.id && (_this.config.renderSelectedChoices === 'always' || !choice.selected);
              });
            }; // If sorting is enabled, filter groups


            if (this.config.shouldSort) {
              groups.sort(this.config.sorter);
            }

            groups.forEach(function (group) {
              var groupChoices = getGroupChoices(group);

              if (groupChoices.length >= 1) {
                var dropdownGroup = _this._getTemplate('choiceGroup', group);

                fragment.appendChild(dropdownGroup);

                _this._createChoicesFragment(groupChoices, fragment, true);
              }
            });
            return fragment;
          };

          Choices.prototype._createChoicesFragment = function (choices, fragment, withinGroup) {
            var _this = this;

            if (fragment === void 0) {
              fragment = document.createDocumentFragment();
            }

            if (withinGroup === void 0) {
              withinGroup = false;
            } // Create a fragment to store our list items (so we don't have to update the DOM for each item)


            var _a = this.config,
              renderSelectedChoices = _a.renderSelectedChoices,
              searchResultLimit = _a.searchResultLimit,
              renderChoiceLimit = _a.renderChoiceLimit;
            var filter = this._isSearching ? utils_1.sortByScore : this.config.sorter;

            var appendChoice = function appendChoice(choice) {
              var shouldRender = renderSelectedChoices === 'auto' ? _this._isSelectOneElement || !choice.selected : true;

              if (shouldRender) {
                var dropdownItem = _this._getTemplate('choice', choice, _this.config.itemSelectText);

                fragment.appendChild(dropdownItem);
              }
            };

            var rendererableChoices = choices;

            if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {
              rendererableChoices = choices.filter(function (choice) {
                return !choice.selected;
              });
            } // Split array into placeholders and "normal" choices


            var _b = rendererableChoices.reduce(function (acc, choice) {
              if (choice.placeholder) {
                acc.placeholderChoices.push(choice);
              } else {
                acc.normalChoices.push(choice);
              }

              return acc;
            }, {
              placeholderChoices: [],
              normalChoices: []
            }),
              placeholderChoices = _b.placeholderChoices,
              normalChoices = _b.normalChoices; // If sorting is enabled or the user is searching, filter choices


            if (this.config.shouldSort || this._isSearching) {
              normalChoices.sort(filter);
            }

            var choiceLimit = rendererableChoices.length; // Prepend placeholeder

            var sortedChoices = this._isSelectOneElement ? __spreadArrays(placeholderChoices, normalChoices) : normalChoices;

            if (this._isSearching) {
              choiceLimit = searchResultLimit;
            } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
              choiceLimit = renderChoiceLimit;
            } // Add each choice to dropdown within range


            for (var i = 0; i < choiceLimit; i += 1) {
              if (sortedChoices[i]) {
                appendChoice(sortedChoices[i]);
              }
            }

            return fragment;
          };

          Choices.prototype._createItemsFragment = function (items, fragment) {
            var _this = this;

            if (fragment === void 0) {
              fragment = document.createDocumentFragment();
            } // Create fragment to add elements to


            var _a = this.config,
              shouldSortItems = _a.shouldSortItems,
              sorter = _a.sorter,
              removeItemButton = _a.removeItemButton; // If sorting is enabled, filter items

            if (shouldSortItems && !this._isSelectOneElement) {
              items.sort(sorter);
            }

            if (this._isTextElement) {
              // Update the value of the hidden input
              this.passedElement.value = items.map(function (_a) {
                var value = _a.value;
                return value;
              }).join(this.config.delimiter);
            } else {
              // Update the options of the hidden input
              this.passedElement.options = items;
            }

            var addItemToFragment = function addItemToFragment(item) {
              // Create new list element
              var listItem = _this._getTemplate('item', item, removeItemButton); // Append it to list


              fragment.appendChild(listItem);
            }; // Add each list item to list


            items.forEach(addItemToFragment);
            return fragment;
          };

          Choices.prototype._triggerChange = function (value) {
            if (value === undefined || value === null) {
              return;
            }

            this.passedElement.triggerEvent(constants_1.EVENTS.change, {
              value: value
            });
          };

          Choices.prototype._selectPlaceholderChoice = function (placeholderChoice) {
            this._addItem({
              value: placeholderChoice.value,
              label: placeholderChoice.label,
              choiceId: placeholderChoice.id,
              groupId: placeholderChoice.groupId,
              placeholder: placeholderChoice.placeholder
            });

            this._triggerChange(placeholderChoice.value);
          };

          Choices.prototype._handleButtonAction = function (activeItems, element) {
            if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
              return;
            }

            var itemId = element.parentNode && element.parentNode.dataset.id;
            var itemToRemove = itemId && activeItems.find(function (item) {
              return item.id === parseInt(itemId, 10);
            });

            if (!itemToRemove) {
              return;
            } // Remove item associated with button


            this._removeItem(itemToRemove);

            this._triggerChange(itemToRemove.value);

            if (this._isSelectOneElement && this._store.placeholderChoice) {
              this._selectPlaceholderChoice(this._store.placeholderChoice);
            }
          };

          Choices.prototype._handleItemAction = function (activeItems, element, hasShiftKey) {
            var _this = this;

            if (hasShiftKey === void 0) {
              hasShiftKey = false;
            }

            if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
              return;
            }

            var passedId = element.dataset.id; // We only want to select one item with a click
            // so we deselect any items that aren't the target
            // unless shift is being pressed

            activeItems.forEach(function (item) {
              if (item.id === parseInt("" + passedId, 10) && !item.highlighted) {
                _this.highlightItem(item);
              } else if (!hasShiftKey && item.highlighted) {
                _this.unhighlightItem(item);
              }
            }); // Focus input as without focus, a user cannot do anything with a
            // highlighted item

            this.input.focus();
          };

          Choices.prototype._handleChoiceAction = function (activeItems, element) {
            if (!activeItems || !element) {
              return;
            } // If we are clicking on an option


            var id = element.dataset.id;

            var choice = id && this._store.getChoiceById(id);

            if (!choice) {
              return;
            }

            var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : undefined;
            var hasActiveDropdown = this.dropdown.isActive; // Update choice keyCode

            choice.keyCode = passedKeyCode;
            this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
              choice: choice
            });

            if (!choice.selected && !choice.disabled) {
              var canAddItem = this._canAddItem(activeItems, choice.value);

              if (canAddItem.response) {
                this._addItem({
                  value: choice.value,
                  label: choice.label,
                  choiceId: choice.id,
                  groupId: choice.groupId,
                  customProperties: choice.customProperties,
                  placeholder: choice.placeholder,
                  keyCode: choice.keyCode
                });

                this._triggerChange(choice.value);
              }
            }

            this.clearInput(); // We want to close the dropdown if we are dealing with a single select box

            if (hasActiveDropdown && this._isSelectOneElement) {
              this.hideDropdown(true);
              this.containerOuter.focus();
            }
          };

          Choices.prototype._handleBackspace = function (activeItems) {
            if (!this.config.removeItems || !activeItems) {
              return;
            }

            var lastItem = activeItems[activeItems.length - 1];
            var hasHighlightedItems = activeItems.some(function (item) {
              return item.highlighted;
            }); // If editing the last item is allowed and there are not other selected items,
            // we can edit the item value. Otherwise if we can remove items, remove all selected items

            if (this.config.editItems && !hasHighlightedItems && lastItem) {
              this.input.value = lastItem.value;
              this.input.setWidth();

              this._removeItem(lastItem);

              this._triggerChange(lastItem.value);
            } else {
              if (!hasHighlightedItems) {
                // Highlight last item if none already highlighted
                this.highlightItem(lastItem, false);
              }

              this.removeHighlightedItems(true);
            }
          };

          Choices.prototype._startLoading = function () {
            this._store.dispatch(misc_1.setIsLoading(true));
          };

          Choices.prototype._stopLoading = function () {
            this._store.dispatch(misc_1.setIsLoading(false));
          };

          Choices.prototype._handleLoadingState = function (setLoading) {
            if (setLoading === void 0) {
              setLoading = true;
            }

            var placeholderItem = this.itemList.getChild("." + this.config.classNames.placeholder);

            if (setLoading) {
              this.disable();
              this.containerOuter.addLoadingState();

              if (this._isSelectOneElement) {
                if (!placeholderItem) {
                  placeholderItem = this._getTemplate('placeholder', this.config.loadingText);

                  if (placeholderItem) {
                    this.itemList.append(placeholderItem);
                  }
                } else {
                  placeholderItem.innerHTML = this.config.loadingText;
                }
              } else {
                this.input.placeholder = this.config.loadingText;
              }
            } else {
              this.enable();
              this.containerOuter.removeLoadingState();

              if (this._isSelectOneElement) {
                if (placeholderItem) {
                  placeholderItem.innerHTML = this._placeholderValue || '';
                }
              } else {
                this.input.placeholder = this._placeholderValue || '';
              }
            }
          };

          Choices.prototype._handleSearch = function (value) {
            if (!value || !this.input.isFocussed) {
              return;
            }

            var choices = this._store.choices;
            var _a = this.config,
              searchFloor = _a.searchFloor,
              searchChoices = _a.searchChoices;
            var hasUnactiveChoices = choices.some(function (option) {
              return !option.active;
            }); // Check that we have a value to search and the input was an alphanumeric character

            if (value && value.length >= searchFloor) {
              var resultCount = searchChoices ? this._searchChoices(value) : 0; // Trigger search event

              this.passedElement.triggerEvent(constants_1.EVENTS.search, {
                value: value,
                resultCount: resultCount
              });
            } else if (hasUnactiveChoices) {
              // Otherwise reset choices to active
              this._isSearching = false;

              this._store.dispatch(choices_1.activateChoices(true));
            }
          };

          Choices.prototype._canAddItem = function (activeItems, value) {
            var canAddItem = true;
            var notice = typeof this.config.addItemText === 'function' ? this.config.addItemText(value) : this.config.addItemText;

            if (!this._isSelectOneElement) {
              var isDuplicateValue = utils_1.existsInArray(activeItems, value);

              if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
                // If there is a max entry limit and we have reached that limit
                // don't update
                canAddItem = false;
                notice = typeof this.config.maxItemText === 'function' ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
              }

              if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
                canAddItem = false;
                notice = typeof this.config.uniqueItemText === 'function' ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
              }

              if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === 'function' && !this.config.addItemFilter(value)) {
                canAddItem = false;
                notice = typeof this.config.customAddItemText === 'function' ? this.config.customAddItemText(value) : this.config.customAddItemText;
              }
            }

            return {
              response: canAddItem,
              notice: notice
            };
          };

          Choices.prototype._searchChoices = function (value) {
            var newValue = typeof value === 'string' ? value.trim() : value;
            var currentValue = typeof this._currentValue === 'string' ? this._currentValue.trim() : this._currentValue;

            if (newValue.length < 1 && newValue === currentValue + " ") {
              return 0;
            } // If new value matches the desired length and is not the same as the current value with a space


            var haystack = this._store.searchableChoices;
            var needle = newValue;

            var keys = __spreadArrays(this.config.searchFields);

            var options = Object.assign(this.config.fuseOptions, {
              keys: keys,
              includeMatches: true
            });
            var fuse = new fuse_js_1.default(haystack, options);
            var results = fuse.search(needle); // see https://github.com/krisk/Fuse/issues/303

            this._currentValue = newValue;
            this._highlightPosition = 0;
            this._isSearching = true;

            this._store.dispatch(choices_1.filterChoices(results));

            return results.length;
          };

          Choices.prototype._addEventListeners = function () {
            var documentElement = document.documentElement; // capture events - can cancel event processing or propagation

            documentElement.addEventListener('touchend', this._onTouchEnd, true);
            this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);
            this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true); // passive events - doesn't call `preventDefault` or `stopPropagation`

            documentElement.addEventListener('click', this._onClick, {
              passive: true
            });
            documentElement.addEventListener('touchmove', this._onTouchMove, {
              passive: true
            });
            this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
              passive: true
            });

            if (this._isSelectOneElement) {
              this.containerOuter.element.addEventListener('focus', this._onFocus, {
                passive: true
              });
              this.containerOuter.element.addEventListener('blur', this._onBlur, {
                passive: true
              });
            }

            this.input.element.addEventListener('keyup', this._onKeyUp, {
              passive: true
            });
            this.input.element.addEventListener('focus', this._onFocus, {
              passive: true
            });
            this.input.element.addEventListener('blur', this._onBlur, {
              passive: true
            });

            if (this.input.element.form) {
              this.input.element.form.addEventListener('reset', this._onFormReset, {
                passive: true
              });
            }

            this.input.addEventListeners();
          };

          Choices.prototype._removeEventListeners = function () {
            var documentElement = document.documentElement;
            documentElement.removeEventListener('touchend', this._onTouchEnd, true);
            this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);
            this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);
            documentElement.removeEventListener('click', this._onClick);
            documentElement.removeEventListener('touchmove', this._onTouchMove);
            this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);

            if (this._isSelectOneElement) {
              this.containerOuter.element.removeEventListener('focus', this._onFocus);
              this.containerOuter.element.removeEventListener('blur', this._onBlur);
            }

            this.input.element.removeEventListener('keyup', this._onKeyUp);
            this.input.element.removeEventListener('focus', this._onFocus);
            this.input.element.removeEventListener('blur', this._onBlur);

            if (this.input.element.form) {
              this.input.element.form.removeEventListener('reset', this._onFormReset);
            }

            this.input.removeEventListeners();
          };

          Choices.prototype._onKeyDown = function (event) {
            var keyCode = event.keyCode;
            var activeItems = this._store.activeItems;
            var hasFocusedInput = this.input.isFocussed;
            var hasActiveDropdown = this.dropdown.isActive;
            var hasItems = this.itemList.hasChildren();
            var keyString = String.fromCharCode(keyCode);
            var wasAlphaNumericChar = /[a-zA-Z0-9-_ ]/.test(keyString);
            var BACK_KEY = constants_1.KEY_CODES.BACK_KEY,
              DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY,
              ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY,
              A_KEY = constants_1.KEY_CODES.A_KEY,
              ESC_KEY = constants_1.KEY_CODES.ESC_KEY,
              UP_KEY = constants_1.KEY_CODES.UP_KEY,
              DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY,
              PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY,
              PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;

            if (!this._isTextElement && !hasActiveDropdown && wasAlphaNumericChar) {
              this.showDropdown();

              if (!this.input.isFocussed) {
                /*
                  We update the input value with the pressed key as
                  the input was not focussed at the time of key press
                  therefore does not have the value of the key.
                */
                this.input.value += keyString.toLowerCase();
              }
            }

            switch (keyCode) {
              case A_KEY:
                return this._onSelectKey(event, hasItems);

              case ENTER_KEY:
                return this._onEnterKey(event, activeItems, hasActiveDropdown);

              case ESC_KEY:
                return this._onEscapeKey(hasActiveDropdown);

              case UP_KEY:
              case PAGE_UP_KEY:
              case DOWN_KEY:
              case PAGE_DOWN_KEY:
                return this._onDirectionKey(event, hasActiveDropdown);

              case DELETE_KEY:
              case BACK_KEY:
                return this._onDeleteKey(event, activeItems, hasFocusedInput);

              default:
            }
          };

          Choices.prototype._onKeyUp = function (_a) {
            var target = _a.target,
              keyCode = _a.keyCode;
            var value = this.input.value;
            var activeItems = this._store.activeItems;

            var canAddItem = this._canAddItem(activeItems, value);

            var backKey = constants_1.KEY_CODES.BACK_KEY,
              deleteKey = constants_1.KEY_CODES.DELETE_KEY; // We are typing into a text input and have a value, we want to show a dropdown
            // notice. Otherwise hide the dropdown

            if (this._isTextElement) {
              var canShowDropdownNotice = canAddItem.notice && value;

              if (canShowDropdownNotice) {
                var dropdownItem = this._getTemplate('notice', canAddItem.notice);

                this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                this.showDropdown(true);
              } else {
                this.hideDropdown(true);
              }
            } else {
              var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
              var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
              var canReactivateChoices = !this._isTextElement && this._isSearching;
              var canSearch = this._canSearch && canAddItem.response;

              if (userHasRemovedValue && canReactivateChoices) {
                this._isSearching = false;

                this._store.dispatch(choices_1.activateChoices(true));
              } else if (canSearch) {
                this._handleSearch(this.input.value);
              }
            }

            this._canSearch = this.config.searchEnabled;
          };

          Choices.prototype._onSelectKey = function (event, hasItems) {
            var ctrlKey = event.ctrlKey,
              metaKey = event.metaKey;
            var hasCtrlDownKeyPressed = ctrlKey || metaKey; // If CTRL + A or CMD + A have been pressed and there are items to select

            if (hasCtrlDownKeyPressed && hasItems) {
              this._canSearch = false;
              var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;

              if (shouldHightlightAll) {
                this.highlightAll();
              }
            }
          };

          Choices.prototype._onEnterKey = function (event, activeItems, hasActiveDropdown) {
            var target = event.target;
            var enterKey = constants_1.KEY_CODES.ENTER_KEY;
            var targetWasButton = target && target.hasAttribute('data-button');

            if (this._isTextElement && target && target.value) {
              var value = this.input.value;

              var canAddItem = this._canAddItem(activeItems, value);

              if (canAddItem.response) {
                this.hideDropdown(true);

                this._addItem({
                  value: value
                });

                this._triggerChange(value);

                this.clearInput();
              }
            }

            if (targetWasButton) {
              this._handleButtonAction(activeItems, target);

              event.preventDefault();
            }

            if (hasActiveDropdown) {
              var highlightedChoice = this.dropdown.getChild("." + this.config.classNames.highlightedState);

              if (highlightedChoice) {
                // add enter keyCode value
                if (activeItems[0]) {
                  activeItems[0].keyCode = enterKey; // eslint-disable-line no-param-reassign
                }

                this._handleChoiceAction(activeItems, highlightedChoice);
              }

              event.preventDefault();
            } else if (this._isSelectOneElement) {
              this.showDropdown();
              event.preventDefault();
            }
          };

          Choices.prototype._onEscapeKey = function (hasActiveDropdown) {
            if (hasActiveDropdown) {
              this.hideDropdown(true);
              this.containerOuter.focus();
            }
          };

          Choices.prototype._onDirectionKey = function (event, hasActiveDropdown) {
            var keyCode = event.keyCode,
              metaKey = event.metaKey;
            var downKey = constants_1.KEY_CODES.DOWN_KEY,
              pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY,
              pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY; // If up or down key is pressed, traverse through options

            if (hasActiveDropdown || this._isSelectOneElement) {
              this.showDropdown();
              this._canSearch = false;
              var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
              var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
              var selectableChoiceIdentifier = '[data-choice-selectable]';
              var nextEl = void 0;

              if (skipKey) {
                if (directionInt > 0) {
                  nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier + ":last-of-type");
                } else {
                  nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                }
              } else {
                var currentEl = this.dropdown.element.querySelector("." + this.config.classNames.highlightedState);

                if (currentEl) {
                  nextEl = utils_1.getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);
                } else {
                  nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                }
              }

              if (nextEl) {
                // We prevent default to stop the cursor moving
                // when pressing the arrow
                if (!utils_1.isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {
                  this.choiceList.scrollToChildElement(nextEl, directionInt);
                }

                this._highlightChoice(nextEl);
              } // Prevent default to maintain cursor position whilst
              // traversing dropdown options


              event.preventDefault();
            }
          };

          Choices.prototype._onDeleteKey = function (event, activeItems, hasFocusedInput) {
            var target = event.target; // If backspace or delete key is pressed and the input has no value

            if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
              this._handleBackspace(activeItems);

              event.preventDefault();
            }
          };

          Choices.prototype._onTouchMove = function () {
            if (this._wasTap) {
              this._wasTap = false;
            }
          };

          Choices.prototype._onTouchEnd = function (event) {
            var target = (event || event.touches[0]).target;
            var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);

            if (touchWasWithinContainer) {
              var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;

              if (containerWasExactTarget) {
                if (this._isTextElement) {
                  this.input.focus();
                } else if (this._isSelectMultipleElement) {
                  this.showDropdown();
                }
              } // Prevents focus event firing


              event.stopPropagation();
            }

            this._wasTap = true;
          };
          /**
           * Handles mousedown event in capture mode for containetOuter.element
           */


          Choices.prototype._onMouseDown = function (event) {
            var target = event.target;

            if (!(target instanceof HTMLElement)) {
              return;
            } // If we have our mouse down on the scrollbar and are on IE11...


            if (IS_IE11 && this.choiceList.element.contains(target)) {
              // check if click was on a scrollbar area
              var firstChoice = this.choiceList.element.firstElementChild;
              var isOnScrollbar = this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
              this._isScrollingOnIe = isOnScrollbar;
            }

            if (target === this.input.element) {
              return;
            }

            var item = target.closest('[data-button],[data-item],[data-choice]');

            if (item instanceof HTMLElement) {
              var hasShiftKey = event.shiftKey;
              var activeItems = this._store.activeItems;
              var dataset = item.dataset;

              if ('button' in dataset) {
                this._handleButtonAction(activeItems, item);
              } else if ('item' in dataset) {
                this._handleItemAction(activeItems, item, hasShiftKey);
              } else if ('choice' in dataset) {
                this._handleChoiceAction(activeItems, item);
              }
            }

            event.preventDefault();
          };
          /**
           * Handles mouseover event over this.dropdown
           * @param {MouseEvent} event
           */


          Choices.prototype._onMouseOver = function (_a) {
            var target = _a.target;

            if (target instanceof HTMLElement && 'choice' in target.dataset) {
              this._highlightChoice(target);
            }
          };

          Choices.prototype._onClick = function (_a) {
            var target = _a.target;
            var clickWasWithinContainer = this.containerOuter.element.contains(target);

            if (clickWasWithinContainer) {
              if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                if (this._isTextElement) {
                  if (document.activeElement !== this.input.element) {
                    this.input.focus();
                  }
                } else {
                  this.showDropdown();
                  this.containerOuter.focus();
                }
              } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
                this.hideDropdown();
              }
            } else {
              var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;

              if (hasHighlightedItems) {
                this.unhighlightAll();
              }

              this.containerOuter.removeFocusState();
              this.hideDropdown(true);
            }
          };

          Choices.prototype._onFocus = function (_a) {
            var _b;

            var _this = this;

            var target = _a.target;
            var focusWasWithinContainer = target && this.containerOuter.element.contains(target);

            if (!focusWasWithinContainer) {
              return;
            }

            var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function () {
              if (target === _this.input.element) {
                _this.containerOuter.addFocusState();
              }
            }, _b[constants_1.SELECT_ONE_TYPE] = function () {
              _this.containerOuter.addFocusState();

              if (target === _this.input.element) {
                _this.showDropdown(true);
              }
            }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
              if (target === _this.input.element) {
                _this.showDropdown(true); // If element is a select box, the focused element is the container and the dropdown
                // isn't already open, focus and show dropdown


                _this.containerOuter.addFocusState();
              }
            }, _b);
            focusActions[this.passedElement.element.type]();
          };

          Choices.prototype._onBlur = function (_a) {
            var _b;

            var _this = this;

            var target = _a.target;
            var blurWasWithinContainer = target && this.containerOuter.element.contains(target);

            if (blurWasWithinContainer && !this._isScrollingOnIe) {
              var activeItems = this._store.activeItems;
              var hasHighlightedItems_1 = activeItems.some(function (item) {
                return item.highlighted;
              });
              var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function () {
                if (target === _this.input.element) {
                  _this.containerOuter.removeFocusState();

                  if (hasHighlightedItems_1) {
                    _this.unhighlightAll();
                  }

                  _this.hideDropdown(true);
                }
              }, _b[constants_1.SELECT_ONE_TYPE] = function () {
                _this.containerOuter.removeFocusState();

                if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
                  _this.hideDropdown(true);
                }
              }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
                if (target === _this.input.element) {
                  _this.containerOuter.removeFocusState();

                  _this.hideDropdown(true);

                  if (hasHighlightedItems_1) {
                    _this.unhighlightAll();
                  }
                }
              }, _b);
              blurActions[this.passedElement.element.type]();
            } else {
              // On IE11, clicking the scollbar blurs our input and thus
              // closes the dropdown. To stop this, we refocus our input
              // if we know we are on IE *and* are scrolling.
              this._isScrollingOnIe = false;
              this.input.element.focus();
            }
          };

          Choices.prototype._onFormReset = function () {
            this._store.dispatch(misc_1.resetTo(this._initialState));
          };

          Choices.prototype._highlightChoice = function (el) {
            var _this = this;

            if (el === void 0) {
              el = null;
            }

            var choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));

            if (!choices.length) {
              return;
            }

            var passedEl = el;
            var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll("." + this.config.classNames.highlightedState)); // Remove any highlighted choices

            highlightedChoices.forEach(function (choice) {
              choice.classList.remove(_this.config.classNames.highlightedState);
              choice.setAttribute('aria-selected', 'false');
            });

            if (passedEl) {
              this._highlightPosition = choices.indexOf(passedEl);
            } else {
              // Highlight choice based on last known highlight location
              if (choices.length > this._highlightPosition) {
                // If we have an option to highlight
                passedEl = choices[this._highlightPosition];
              } else {
                // Otherwise highlight the option before
                passedEl = choices[choices.length - 1];
              }

              if (!passedEl) {
                passedEl = choices[0];
              }
            }

            passedEl.classList.add(this.config.classNames.highlightedState);
            passedEl.setAttribute('aria-selected', 'true');
            this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
              el: passedEl
            });

            if (this.dropdown.isActive) {
              // IE11 ignores aria-label and blocks virtual keyboard
              // if aria-activedescendant is set without a dropdown
              this.input.setActiveDescendant(passedEl.id);
              this.containerOuter.setActiveDescendant(passedEl.id);
            }
          };

          Choices.prototype._addItem = function (_a) {
            var value = _a.value,
              _b = _a.label,
              label = _b === void 0 ? null : _b,
              _c = _a.choiceId,
              choiceId = _c === void 0 ? -1 : _c,
              _d = _a.groupId,
              groupId = _d === void 0 ? -1 : _d,
              _e = _a.customProperties,
              customProperties = _e === void 0 ? {} : _e,
              _f = _a.placeholder,
              placeholder = _f === void 0 ? false : _f,
              _g = _a.keyCode,
              keyCode = _g === void 0 ? -1 : _g;
            var passedValue = typeof value === 'string' ? value.trim() : value;
            var items = this._store.items;
            var passedLabel = label || passedValue;
            var passedOptionId = choiceId || -1;
            var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            var id = items ? items.length + 1 : 1; // If a prepended value has been passed, prepend it

            if (this.config.prependValue) {
              passedValue = this.config.prependValue + passedValue.toString();
            } // If an appended value has been passed, append it


            if (this.config.appendValue) {
              passedValue += this.config.appendValue.toString();
            }

            this._store.dispatch(items_1.addItem({
              value: passedValue,
              label: passedLabel,
              id: id,
              choiceId: passedOptionId,
              groupId: groupId,
              customProperties: customProperties,
              placeholder: placeholder,
              keyCode: keyCode
            }));

            if (this._isSelectOneElement) {
              this.removeActiveItems(id);
            } // Trigger change event


            this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
              id: id,
              value: passedValue,
              label: passedLabel,
              customProperties: customProperties,
              groupValue: group && group.value ? group.value : null,
              keyCode: keyCode
            });
          };

          Choices.prototype._removeItem = function (item) {
            var id = item.id,
              value = item.value,
              label = item.label,
              customProperties = item.customProperties,
              choiceId = item.choiceId,
              groupId = item.groupId;
            var group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;

            if (!id || !choiceId) {
              return;
            }

            this._store.dispatch(items_1.removeItem(id, choiceId));

            this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
              id: id,
              value: value,
              label: label,
              customProperties: customProperties,
              groupValue: group && group.value ? group.value : null
            });
          };

          Choices.prototype._addChoice = function (_a) {
            var value = _a.value,
              _b = _a.label,
              label = _b === void 0 ? null : _b,
              _c = _a.isSelected,
              isSelected = _c === void 0 ? false : _c,
              _d = _a.isDisabled,
              isDisabled = _d === void 0 ? false : _d,
              _e = _a.groupId,
              groupId = _e === void 0 ? -1 : _e,
              _f = _a.customProperties,
              customProperties = _f === void 0 ? {} : _f,
              _g = _a.placeholder,
              placeholder = _g === void 0 ? false : _g,
              _h = _a.keyCode,
              keyCode = _h === void 0 ? -1 : _h;

            if (typeof value === 'undefined' || value === null) {
              return;
            } // Generate unique id


            var choices = this._store.choices;
            var choiceLabel = label || value;
            var choiceId = choices ? choices.length + 1 : 1;
            var choiceElementId = this._baseId + "-" + this._idNames.itemChoice + "-" + choiceId;

            this._store.dispatch(choices_1.addChoice({
              id: choiceId,
              groupId: groupId,
              elementId: choiceElementId,
              value: value,
              label: choiceLabel,
              disabled: isDisabled,
              customProperties: customProperties,
              placeholder: placeholder,
              keyCode: keyCode
            }));

            if (isSelected) {
              this._addItem({
                value: value,
                label: choiceLabel,
                choiceId: choiceId,
                customProperties: customProperties,
                placeholder: placeholder,
                keyCode: keyCode
              });
            }
          };

          Choices.prototype._addGroup = function (_a) {
            var _this = this;

            var group = _a.group,
              id = _a.id,
              _b = _a.valueKey,
              valueKey = _b === void 0 ? 'value' : _b,
              _c = _a.labelKey,
              labelKey = _c === void 0 ? 'label' : _c;
            var groupChoices = utils_1.isType('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));
            var groupId = id || Math.floor(new Date().valueOf() * Math.random());
            var isDisabled = group.disabled ? group.disabled : false;

            if (groupChoices) {
              this._store.dispatch(groups_1.addGroup({
                value: group.label,
                id: groupId,
                active: true,
                disabled: isDisabled
              }));

              var addGroupChoices = function addGroupChoices(choice) {
                var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;

                _this._addChoice({
                  value: choice[valueKey],
                  label: utils_1.isType('Object', choice) ? choice[labelKey] : choice.innerHTML,
                  isSelected: choice.selected,
                  isDisabled: isOptDisabled,
                  groupId: groupId,
                  customProperties: choice.customProperties,
                  placeholder: choice.placeholder
                });
              };

              groupChoices.forEach(addGroupChoices);
            } else {
              this._store.dispatch(groups_1.addGroup({
                value: group.label,
                id: group.id,
                active: false,
                disabled: group.disabled
              }));
            }
          };

          Choices.prototype._getTemplate = function (template) {
            var _a;

            var args = [];

            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }

            var classNames = this.config.classNames;
            return (_a = this._templates[template]).call.apply(_a, __spreadArrays([this, classNames], args));
          };

          Choices.prototype._createTemplates = function () {
            var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
            var userTemplates = {};

            if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === 'function') {
              userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
            }

            this._templates = deepmerge_1.default(templates_1.default, userTemplates);
          };

          Choices.prototype._createElements = function () {
            this.containerOuter = new components_1.Container({
              element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type),
              classNames: this.config.classNames,
              type: this.passedElement.element.type,
              position: this.config.position
            });
            this.containerInner = new components_1.Container({
              element: this._getTemplate('containerInner'),
              classNames: this.config.classNames,
              type: this.passedElement.element.type,
              position: this.config.position
            });
            this.input = new components_1.Input({
              element: this._getTemplate('input', this._placeholderValue),
              classNames: this.config.classNames,
              type: this.passedElement.element.type,
              preventPaste: !this.config.paste
            });
            this.choiceList = new components_1.List({
              element: this._getTemplate('choiceList', this._isSelectOneElement)
            });
            this.itemList = new components_1.List({
              element: this._getTemplate('itemList', this._isSelectOneElement)
            });
            this.dropdown = new components_1.Dropdown({
              element: this._getTemplate('dropdown'),
              classNames: this.config.classNames,
              type: this.passedElement.element.type
            });
          };

          Choices.prototype._createStructure = function () {
            // Hide original element
            this.passedElement.conceal(); // Wrap input in container preserving DOM ordering

            this.containerInner.wrap(this.passedElement.element); // Wrapper inner container with outer container

            this.containerOuter.wrap(this.containerInner.element);

            if (this._isSelectOneElement) {
              this.input.placeholder = this.config.searchPlaceholderValue || '';
            } else if (this._placeholderValue) {
              this.input.placeholder = this._placeholderValue;
              this.input.setWidth();
            }

            this.containerOuter.element.appendChild(this.containerInner.element);
            this.containerOuter.element.appendChild(this.dropdown.element);
            this.containerInner.element.appendChild(this.itemList.element);

            if (!this._isTextElement) {
              this.dropdown.element.appendChild(this.choiceList.element);
            }

            if (!this._isSelectOneElement) {
              this.containerInner.element.appendChild(this.input.element);
            } else if (this.config.searchEnabled) {
              this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
            }

            if (this._isSelectElement) {
              this._highlightPosition = 0;
              this._isSearching = false;

              this._startLoading();

              if (this._presetGroups.length) {
                this._addPredefinedGroups(this._presetGroups);
              } else {
                this._addPredefinedChoices(this._presetChoices);
              }

              this._stopLoading();
            }

            if (this._isTextElement) {
              this._addPredefinedItems(this._presetItems);
            }
          };

          Choices.prototype._addPredefinedGroups = function (groups) {
            var _this = this; // If we have a placeholder option


            var placeholderChoice = this.passedElement.placeholderOption;

            if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === 'SELECT') {
              this._addChoice({
                value: placeholderChoice.value,
                label: placeholderChoice.innerHTML,
                isSelected: placeholderChoice.selected,
                isDisabled: placeholderChoice.disabled,
                placeholder: true
              });
            }

            groups.forEach(function (group) {
              return _this._addGroup({
                group: group,
                id: group.id || null
              });
            });
          };

          Choices.prototype._addPredefinedChoices = function (choices) {
            var _this = this; // If sorting is enabled or the user is searching, filter choices


            if (this.config.shouldSort) {
              choices.sort(this.config.sorter);
            }

            var hasSelectedChoice = choices.some(function (choice) {
              return choice.selected;
            });
            var firstEnabledChoiceIndex = choices.findIndex(function (choice) {
              return choice.disabled === undefined || !choice.disabled;
            });
            choices.forEach(function (choice, index) {
              var _a = choice.value,
                value = _a === void 0 ? '' : _a,
                label = choice.label,
                customProperties = choice.customProperties,
                placeholder = choice.placeholder;

              if (_this._isSelectElement) {
                // If the choice is actually a group
                if (choice.choices) {
                  _this._addGroup({
                    group: choice,
                    id: choice.id || null
                  });
                } else {
                  /**
                   * If there is a selected choice already or the choice is not the first in
                   * the array, add each choice normally.
                   *
                   * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
                   */
                  var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;
                  var isSelected = shouldPreselect ? true : choice.selected;
                  var isDisabled = choice.disabled;
                  //console.log(isDisabled, choice);

                  _this._addChoice({
                    value: value,
                    label: label,
                    isSelected: !!isSelected,
                    isDisabled: !!isDisabled,
                    placeholder: !!placeholder,
                    customProperties: customProperties
                  });
                }
              } else {
                _this._addChoice({
                  value: value,
                  label: label,
                  isSelected: !!choice.selected,
                  isDisabled: !!choice.disabled,
                  placeholder: !!choice.placeholder,
                  customProperties: customProperties
                });
              }
            });
          };

          Choices.prototype._addPredefinedItems = function (items) {
            var _this = this;

            items.forEach(function (item) {
              if (typeof item === 'object' && item.value) {
                _this._addItem({
                  value: item.value,
                  label: item.label,
                  choiceId: item.id,
                  customProperties: item.customProperties,
                  placeholder: item.placeholder
                });
              }

              if (typeof item === 'string') {
                _this._addItem({
                  value: item
                });
              }
            });
          };

          Choices.prototype._setChoiceOrItem = function (item) {
            var _this = this;

            var itemType = utils_1.getType(item).toLowerCase();
            var handleType = {
              object: function object() {
                if (!item.value) {
                  return;
                } // If we are dealing with a select input, we need to create an option first
                // that is then selected. For text inputs we can just add items normally.


                if (!_this._isTextElement) {
                  _this._addChoice({
                    value: item.value,
                    label: item.label,
                    isSelected: true,
                    isDisabled: false,
                    customProperties: item.customProperties,
                    placeholder: item.placeholder
                  });
                } else {
                  _this._addItem({
                    value: item.value,
                    label: item.label,
                    choiceId: item.id,
                    customProperties: item.customProperties,
                    placeholder: item.placeholder
                  });
                }
              },
              string: function string() {
                if (!_this._isTextElement) {
                  _this._addChoice({
                    value: item,
                    label: item,
                    isSelected: true,
                    isDisabled: false
                  });
                } else {
                  _this._addItem({
                    value: item
                  });
                }
              }
            };
            handleType[itemType]();
          };

          Choices.prototype._findAndSelectChoiceByValue = function (value) {
            var _this = this;

            var choices = this._store.choices; // Check 'value' property exists and the choice isn't already selected

            var foundChoice = choices.find(function (choice) {
              return _this.config.valueComparer(choice.value, value);
            });

            if (foundChoice && !foundChoice.selected) {
              this._addItem({
                value: foundChoice.value,
                label: foundChoice.label,
                choiceId: foundChoice.id,
                groupId: foundChoice.groupId,
                customProperties: foundChoice.customProperties,
                placeholder: foundChoice.placeholder,
                keyCode: foundChoice.keyCode
              });
            }
          };

          Choices.prototype._generatePlaceholderValue = function () {
            if (this._isSelectElement) {
              var placeholderOption = this.passedElement.placeholderOption;
              return placeholderOption ? placeholderOption.text : null;
            }

            var _a = this.config,
              placeholder = _a.placeholder,
              placeholderValue = _a.placeholderValue;
            var dataset = this.passedElement.element.dataset;

            if (placeholder) {
              if (placeholderValue) {
                return placeholderValue;
              }

              if (dataset.placeholder) {
                return dataset.placeholder;
              }
            }

            return null;
          };

          return Choices;
        }();

      exports.default = Choices;

      /***/
    }),
/* 9 */
/***/ (function (module, exports, __webpack_require__) {

      /*!
       * Fuse.js v3.4.6 - Lightweight fuzzy-search (http://fusejs.io)
       *
       * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
       * All Rights Reserved. Apache Software License 2.0
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       */
      !function (e, t) { true ? module.exports = t() : undefined }(this, function () { return function (e) { var t = {}; function n(r) { if (t[r]) return t[r].exports; var o = t[r] = { i: r, l: !1, exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports } return n.m = e, n.c = t, n.d = function (e, t, r) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r }) }, n.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function (e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) n.d(r, o, function (t) { return e[t] }.bind(null, o)); return r }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 1) }([function (e, t) { e.exports = function (e) { return Array.isArray ? Array.isArray(e) : "[object Array]" === Object.prototype.toString.call(e) } }, function (e, t, n) { function r(e) { return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function o(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } var i = n(2), a = n(8), s = n(0), c = function () { function e(t, n) { var r = n.location, o = void 0 === r ? 0 : r, i = n.distance, s = void 0 === i ? 100 : i, c = n.threshold, h = void 0 === c ? .6 : c, l = n.maxPatternLength, u = void 0 === l ? 32 : l, f = n.caseSensitive, d = void 0 !== f && f, v = n.tokenSeparator, p = void 0 === v ? / +/g : v, g = n.findAllMatches, y = void 0 !== g && g, m = n.minMatchCharLength, k = void 0 === m ? 1 : m, S = n.id, x = void 0 === S ? null : S, b = n.keys, M = void 0 === b ? [] : b, _ = n.shouldSort, L = void 0 === _ || _, w = n.getFn, A = void 0 === w ? a : w, C = n.sortFn, I = void 0 === C ? function (e, t) { return e.score - t.score } : C, O = n.tokenize, j = void 0 !== O && O, P = n.matchAllTokens, F = void 0 !== P && P, T = n.includeMatches, z = void 0 !== T && T, E = n.includeScore, K = void 0 !== E && E, $ = n.verbose, J = void 0 !== $ && $; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.options = { location: o, distance: s, threshold: h, maxPatternLength: u, isCaseSensitive: d, tokenSeparator: p, findAllMatches: y, minMatchCharLength: k, id: x, keys: M, includeMatches: z, includeScore: K, shouldSort: L, getFn: A, sortFn: I, verbose: J, tokenize: j, matchAllTokens: F }, this.setCollection(t) } var t, n, c; return t = e, (n = [{ key: "setCollection", value: function (e) { return this.list = e, e } }, { key: "search", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { limit: !1 }; this._log('---------\nSearch pattern: "'.concat(e, '"')); var n = this._prepareSearchers(e), r = n.tokenSearchers, o = n.fullSearcher, i = this._search(r, o), a = i.weights, s = i.results; return this._computeScore(a, s), this.options.shouldSort && this._sort(s), t.limit && "number" == typeof t.limit && (s = s.slice(0, t.limit)), this._format(s) } }, { key: "_prepareSearchers", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", t = []; if (this.options.tokenize) for (var n = e.split(this.options.tokenSeparator), r = 0, o = n.length; r < o; r += 1)t.push(new i(n[r], this.options)); return { tokenSearchers: t, fullSearcher: new i(e, this.options) } } }, { key: "_search", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 ? arguments[1] : void 0, n = this.list, r = {}, o = []; if ("string" == typeof n[0]) { for (var i = 0, a = n.length; i < a; i += 1)this._analyze({ key: "", value: n[i], record: i, index: i }, { resultMap: r, results: o, tokenSearchers: e, fullSearcher: t }); return { weights: null, results: o } } for (var s = {}, c = 0, h = n.length; c < h; c += 1)for (var l = n[c], u = 0, f = this.options.keys.length; u < f; u += 1) { var d = this.options.keys[u]; if ("string" != typeof d) { if (s[d.name] = { weight: 1 - d.weight || 1 }, d.weight <= 0 || d.weight > 1) throw new Error("Key weight has to be > 0 and <= 1"); d = d.name } else s[d] = { weight: 1 }; this._analyze({ key: d, value: this.options.getFn(l, d), record: l, index: c }, { resultMap: r, results: o, tokenSearchers: e, fullSearcher: t }) } return { weights: s, results: o } } }, { key: "_analyze", value: function (e, t) { var n = e.key, r = e.arrayIndex, o = void 0 === r ? -1 : r, i = e.value, a = e.record, c = e.index, h = t.tokenSearchers, l = void 0 === h ? [] : h, u = t.fullSearcher, f = void 0 === u ? [] : u, d = t.resultMap, v = void 0 === d ? {} : d, p = t.results, g = void 0 === p ? [] : p; if (null != i) { var y = !1, m = -1, k = 0; if ("string" == typeof i) { this._log("\nKey: ".concat("" === n ? "-" : n)); var S = f.search(i); if (this._log('Full text: "'.concat(i, '", score: ').concat(S.score)), this.options.tokenize) { for (var x = i.split(this.options.tokenSeparator), b = [], M = 0; M < l.length; M += 1) { var _ = l[M]; this._log('\nPattern: "'.concat(_.pattern, '"')); for (var L = !1, w = 0; w < x.length; w += 1) { var A = x[w], C = _.search(A), I = {}; C.isMatch ? (I[A] = C.score, y = !0, L = !0, b.push(C.score)) : (I[A] = 1, this.options.matchAllTokens || b.push(1)), this._log('Token: "'.concat(A, '", score: ').concat(I[A])) } L && (k += 1) } m = b[0]; for (var O = b.length, j = 1; j < O; j += 1)m += b[j]; m /= O, this._log("Token score average:", m) } var P = S.score; m > -1 && (P = (P + m) / 2), this._log("Score average:", P); var F = !this.options.tokenize || !this.options.matchAllTokens || k >= l.length; if (this._log("\nCheck Matches: ".concat(F)), (y || S.isMatch) && F) { var T = v[c]; T ? T.output.push({ key: n, arrayIndex: o, value: i, score: P, matchedIndices: S.matchedIndices }) : (v[c] = { item: a, output: [{ key: n, arrayIndex: o, value: i, score: P, matchedIndices: S.matchedIndices }] }, g.push(v[c])) } } else if (s(i)) for (var z = 0, E = i.length; z < E; z += 1)this._analyze({ key: n, arrayIndex: z, value: i[z], record: a, index: c }, { resultMap: v, results: g, tokenSearchers: l, fullSearcher: f }) } } }, { key: "_computeScore", value: function (e, t) { this._log("\n\nComputing score:\n"); for (var n = 0, r = t.length; n < r; n += 1) { for (var o = t[n].output, i = o.length, a = 1, s = 1, c = 0; c < i; c += 1) { var h = e ? e[o[c].key].weight : 1, l = (1 === h ? o[c].score : o[c].score || .001) * h; 1 !== h ? s = Math.min(s, l) : (o[c].nScore = l, a *= l) } t[n].score = 1 === s ? a : s, this._log(t[n]) } } }, { key: "_sort", value: function (e) { this._log("\n\nSorting...."), e.sort(this.options.sortFn) } }, { key: "_format", value: function (e) { var t = []; if (this.options.verbose) { var n = []; this._log("\n\nOutput:\n\n", JSON.stringify(e, function (e, t) { if ("object" === r(t) && null !== t) { if (-1 !== n.indexOf(t)) return; n.push(t) } return t })), n = null } var o = []; this.options.includeMatches && o.push(function (e, t) { var n = e.output; t.matches = []; for (var r = 0, o = n.length; r < o; r += 1) { var i = n[r]; if (0 !== i.matchedIndices.length) { var a = { indices: i.matchedIndices, value: i.value }; i.key && (a.key = i.key), i.hasOwnProperty("arrayIndex") && i.arrayIndex > -1 && (a.arrayIndex = i.arrayIndex), t.matches.push(a) } } }), this.options.includeScore && o.push(function (e, t) { t.score = e.score }); for (var i = 0, a = e.length; i < a; i += 1) { var s = e[i]; if (this.options.id && (s.item = this.options.getFn(s.item, this.options.id)[0]), o.length) { for (var c = { item: s.item }, h = 0, l = o.length; h < l; h += 1)o[h](s, c); t.push(c) } else t.push(s.item) } return t } }, { key: "_log", value: function () { var e; this.options.verbose && (e = console).log.apply(e, arguments) } }]) && o(t.prototype, n), c && o(t, c), e }(); e.exports = c }, function (e, t, n) { function r(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } var o = n(3), i = n(4), a = n(7), s = function () { function e(t, n) { var r = n.location, o = void 0 === r ? 0 : r, i = n.distance, s = void 0 === i ? 100 : i, c = n.threshold, h = void 0 === c ? .6 : c, l = n.maxPatternLength, u = void 0 === l ? 32 : l, f = n.isCaseSensitive, d = void 0 !== f && f, v = n.tokenSeparator, p = void 0 === v ? / +/g : v, g = n.findAllMatches, y = void 0 !== g && g, m = n.minMatchCharLength, k = void 0 === m ? 1 : m; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.options = { location: o, distance: s, threshold: h, maxPatternLength: u, isCaseSensitive: d, tokenSeparator: p, findAllMatches: y, minMatchCharLength: k }, this.pattern = this.options.isCaseSensitive ? t : t.toLowerCase(), this.pattern.length <= u && (this.patternAlphabet = a(this.pattern)) } var t, n, s; return t = e, (n = [{ key: "search", value: function (e) { if (this.options.isCaseSensitive || (e = e.toLowerCase()), this.pattern === e) return { isMatch: !0, score: 0, matchedIndices: [[0, e.length - 1]] }; var t = this.options, n = t.maxPatternLength, r = t.tokenSeparator; if (this.pattern.length > n) return o(e, this.pattern, r); var a = this.options, s = a.location, c = a.distance, h = a.threshold, l = a.findAllMatches, u = a.minMatchCharLength; return i(e, this.pattern, this.patternAlphabet, { location: s, distance: c, threshold: h, findAllMatches: l, minMatchCharLength: u }) } }]) && r(t.prototype, n), s && r(t, s), e }(); e.exports = s }, function (e, t) { var n = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g; e.exports = function (e, t) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : / +/g, o = new RegExp(t.replace(n, "\\$&").replace(r, "|")), i = e.match(o), a = !!i, s = []; if (a) for (var c = 0, h = i.length; c < h; c += 1) { var l = i[c]; s.push([e.indexOf(l), l.length - 1]) } return { score: a ? .5 : 1, isMatch: a, matchedIndices: s } } }, function (e, t, n) { var r = n(5), o = n(6); e.exports = function (e, t, n, i) { for (var a = i.location, s = void 0 === a ? 0 : a, c = i.distance, h = void 0 === c ? 100 : c, l = i.threshold, u = void 0 === l ? .6 : l, f = i.findAllMatches, d = void 0 !== f && f, v = i.minMatchCharLength, p = void 0 === v ? 1 : v, g = s, y = e.length, m = u, k = e.indexOf(t, g), S = t.length, x = [], b = 0; b < y; b += 1)x[b] = 0; if (-1 !== k) { var M = r(t, { errors: 0, currentLocation: k, expectedLocation: g, distance: h }); if (m = Math.min(M, m), -1 !== (k = e.lastIndexOf(t, g + S))) { var _ = r(t, { errors: 0, currentLocation: k, expectedLocation: g, distance: h }); m = Math.min(_, m) } } k = -1; for (var L = [], w = 1, A = S + y, C = 1 << (S <= 31 ? S - 1 : 30), I = 0; I < S; I += 1) { for (var O = 0, j = A; O < j;) { r(t, { errors: I, currentLocation: g + j, expectedLocation: g, distance: h }) <= m ? O = j : A = j, j = Math.floor((A - O) / 2 + O) } A = j; var P = Math.max(1, g - j + 1), F = d ? y : Math.min(g + j, y) + S, T = Array(F + 2); T[F + 1] = (1 << I) - 1; for (var z = F; z >= P; z -= 1) { var E = z - 1, K = n[e.charAt(E)]; if (K && (x[E] = 1), T[z] = (T[z + 1] << 1 | 1) & K, 0 !== I && (T[z] |= (L[z + 1] | L[z]) << 1 | 1 | L[z + 1]), T[z] & C && (w = r(t, { errors: I, currentLocation: E, expectedLocation: g, distance: h })) <= m) { if (m = w, (k = E) <= g) break; P = Math.max(1, 2 * g - k) } } if (r(t, { errors: I + 1, currentLocation: g, expectedLocation: g, distance: h }) > m) break; L = T } return { isMatch: k >= 0, score: 0 === w ? .001 : w, matchedIndices: o(x, p) } } }, function (e, t) { e.exports = function (e, t) { var n = t.errors, r = void 0 === n ? 0 : n, o = t.currentLocation, i = void 0 === o ? 0 : o, a = t.expectedLocation, s = void 0 === a ? 0 : a, c = t.distance, h = void 0 === c ? 100 : c, l = r / e.length, u = Math.abs(s - i); return h ? l + u / h : u ? 1 : l } }, function (e, t) { e.exports = function () { for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = [], r = -1, o = -1, i = 0, a = e.length; i < a; i += 1) { var s = e[i]; s && -1 === r ? r = i : s || -1 === r || ((o = i - 1) - r + 1 >= t && n.push([r, o]), r = -1) } return e[i - 1] && i - r >= t && n.push([r, i - 1]), n } }, function (e, t) { e.exports = function (e) { for (var t = {}, n = e.length, r = 0; r < n; r += 1)t[e.charAt(r)] = 0; for (var o = 0; o < n; o += 1)t[e.charAt(o)] |= 1 << n - o - 1; return t } }, function (e, t, n) { var r = n(0); e.exports = function (e, t) { return function e(t, n, o) { if (n) { var i = n.indexOf("."), a = n, s = null; -1 !== i && (a = n.slice(0, i), s = n.slice(i + 1)); var c = t[a]; if (null != c) if (s || "string" != typeof c && "number" != typeof c) if (r(c)) for (var h = 0, l = c.length; h < l; h += 1)e(c[h], s, o); else s && e(c, s, o); else o.push(c.toString()) } else o.push(t); return o }(e, t, []) } }]) });

      /***/
    }),
/* 10 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var isMergeableObject = function isMergeableObject(value) {
        return isNonNullObject(value)
          && !isSpecial(value)
      };

      function isNonNullObject(value) {
        return !!value && typeof value === 'object'
      }

      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);

        return stringValue === '[object RegExp]'
          || stringValue === '[object Date]'
          || isReactElement(value)
      }

      // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
      var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE
      }

      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {}
      }

      function cloneUnlessOtherwiseSpecified(value, options) {
        return (options.clone !== false && options.isMergeableObject(value))
          ? deepmerge(emptyTarget(value), value, options)
          : value
      }

      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function (element) {
          return cloneUnlessOtherwiseSpecified(element, options)
        })
      }

      function getMergeFunction(key, options) {
        if (!options.customMerge) {
          return deepmerge
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === 'function' ? customMerge : deepmerge
      }

      function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols
          ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
            return target.propertyIsEnumerable(symbol)
          })
          : []
      }

      function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
      }

      // Protects from prototype poisoning and unexpected merging up the prototype chain.
      function propertyIsUnsafe(target, key) {
        try {
          return (key in target) // Properties are safe to merge if they don't exist in the target yet,
            && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
              && Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
        } catch (unused) {
          // Counterintuitively, it's safe to merge any property on a target that causes the `in` operator to throw.
          // This happens when trying to copy an object in the source over a plain string in the target.
          return false
        }
      }

      function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
          getKeys(target).forEach(function (key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }
        getKeys(source).forEach(function (key) {
          if (propertyIsUnsafe(target, key)) {
            return
          }

          if (!options.isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          } else {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
          }
        });
        return destination
      }

      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
        // implementations can use it. The caller may not replace it.
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options)
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options)
        } else {
          return mergeObject(target, source, options)
        }
      }

      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error('first argument should be an array')
        }

        return array.reduce(function (prev, next) {
          return deepmerge(prev, next, options)
        }, {})
      };

      var deepmerge_1 = deepmerge;

      module.exports = deepmerge_1;


      /***/
    }),
/* 11 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __spreadArrays = this && this.__spreadArrays || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
          s += arguments[i].length;
        }

        for (var r = Array(s), k = 0, i = 0; i < il; i++) {
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }

        return r;
      };

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      /* eslint-disable @typescript-eslint/no-explicit-any */

      var redux_1 = __webpack_require__(3);

      var index_1 = __importDefault(__webpack_require__(4));

      var Store =
        /** @class */
        function () {
          function Store() {
            this._store = redux_1.createStore(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
          }
          /**
           * Subscribe store to function call (wrapped Redux method)
           */


          Store.prototype.subscribe = function (onChange) {
            this._store.subscribe(onChange);
          };
          /**
           * Dispatch event to store (wrapped Redux method)
           */


          Store.prototype.dispatch = function (action) {
            this._store.dispatch(action);
          };

          Object.defineProperty(Store.prototype, "state", {
            /**
             * Get store object (wrapping Redux method)
             */
            get: function get() {
              return this._store.getState();
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "items", {
            /**
             * Get items from store
             */
            get: function get() {
              return this.state.items;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "activeItems", {
            /**
             * Get active items from store
             */
            get: function get() {
              return this.items.filter(function (item) {
                return item.active === true;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "highlightedActiveItems", {
            /**
             * Get highlighted items from store
             */
            get: function get() {
              return this.items.filter(function (item) {
                return item.active && item.highlighted;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "choices", {
            /**
             * Get choices from store
             */
            get: function get() {
              return this.state.choices;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "activeChoices", {
            /**
             * Get active choices from store
             */
            get: function get() {
              return this.choices.filter(function (choice) {
                return choice.active === true;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "selectableChoices", {
            /**
             * Get selectable choices from store
             */
            get: function get() {
              return this.choices.filter(function (choice) {
                return choice.disabled !== true;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "searchableChoices", {
            /**
             * Get choices that can be searched (excluding placeholders)
             */
            get: function get() {
              return this.selectableChoices.filter(function (choice) {
                return choice.placeholder !== true;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "placeholderChoice", {
            /**
             * Get placeholder choice from store
             */
            get: function get() {
              return __spreadArrays(this.choices).reverse().find(function (choice) {
                return choice.placeholder === true;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "groups", {
            /**
             * Get groups from store
             */
            get: function get() {
              return this.state.groups;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Store.prototype, "activeGroups", {
            /**
             * Get active groups from store
             */
            get: function get() {
              var _a = this,
                groups = _a.groups,
                choices = _a.choices;

              return groups.filter(function (group) {
                var isActive = group.active === true && group.disabled === false;
                var hasActiveOptions = choices.some(function (choice) {
                  return choice.active === true && choice.disabled === false;
                });
                return isActive && hasActiveOptions;
              }, []);
            },
            enumerable: true,
            configurable: true
          });
          /**
           * Get loading state from store
           */

          Store.prototype.isLoading = function () {
            return this.state.loading;
          };
          /**
           * Get single choice by it's ID
           */


          Store.prototype.getChoiceById = function (id) {
            return this.activeChoices.find(function (choice) {
              return choice.id === parseInt(id, 10);
            });
          };
          /**
           * Get group by group id
           */


          Store.prototype.getGroupById = function (id) {
            return this.groups.find(function (group) {
              return group.id === id;
            });
          };

          return Store;
        }();

      exports.default = Store;

      /***/
    }),
/* 12 */
/***/ (function (module, exports) {

      var g;

      // This works in non-strict mode
      g = (function () {
        return this;
      })();

      try {
        // This works if eval is allowed (see CSP)
        g = g || new Function("return this")();
      } catch (e) {
        // This works if the window reference is available
        if (typeof window === "object") g = window;
      }

      // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}

      module.exports = g;


      /***/
    }),
/* 13 */
/***/ (function (module, exports) {

      module.exports = function (originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule);
          // module.parent = undefined by default
          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function () {
              return module.l;
            }
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function () {
              return module.i;
            }
          });
          Object.defineProperty(module, "exports", {
            enumerable: true
          });
          module.webpackPolyfill = 1;
        }
        return module;
      };


      /***/
    }),
/* 14 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __spreadArrays = this && this.__spreadArrays || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
          s += arguments[i].length;
        }

        for (var r = Array(s), k = 0, i = 0; i < il; i++) {
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }

        return r;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultState = [];

      function items(state, action) {
        if (state === void 0) {
          state = exports.defaultState;
        }

        switch (action.type) {
          case 'ADD_ITEM':
            {
              var addItemAction = action; // Add object to items array

              var newState = __spreadArrays(state, [{
                id: addItemAction.id,
                choiceId: addItemAction.choiceId,
                groupId: addItemAction.groupId,
                value: addItemAction.value,
                label: addItemAction.label,
                active: true,
                highlighted: false,
                customProperties: addItemAction.customProperties,
                placeholder: addItemAction.placeholder || false,
                keyCode: null
              }]);

              return newState.map(function (obj) {
                var item = obj;
                item.highlighted = false;
                return item;
              });
            }

          case 'REMOVE_ITEM':
            {
              // Set item to inactive
              return state.map(function (obj) {
                var item = obj;

                if (item.id === action.id) {
                  item.active = false;
                }

                return item;
              });
            }

          case 'HIGHLIGHT_ITEM':
            {
              var highlightItemAction_1 = action;
              return state.map(function (obj) {
                var item = obj;

                if (item.id === highlightItemAction_1.id) {
                  item.highlighted = highlightItemAction_1.highlighted;
                }

                return item;
              });
            }

          default:
            {
              return state;
            }
        }
      }

      exports.default = items;

      /***/
    }),
/* 15 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __spreadArrays = this && this.__spreadArrays || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
          s += arguments[i].length;
        }

        for (var r = Array(s), k = 0, i = 0; i < il; i++) {
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }

        return r;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultState = [];

      function groups(state, action) {
        if (state === void 0) {
          state = exports.defaultState;
        }

        switch (action.type) {
          case 'ADD_GROUP':
            {
              var addGroupAction = action;
              return __spreadArrays(state, [{
                id: addGroupAction.id,
                value: addGroupAction.value,
                active: addGroupAction.active,
                disabled: addGroupAction.disabled
              }]);
            }

          case 'CLEAR_CHOICES':
            {
              return [];
            }

          default:
            {
              return state;
            }
        }
      }

      exports.default = groups;

      /***/
    }),
/* 16 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __spreadArrays = this && this.__spreadArrays || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
          s += arguments[i].length;
        }

        for (var r = Array(s), k = 0, i = 0; i < il; i++) {
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }

        return r;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultState = [];

      function choices(state, action) {
        if (state === void 0) {
          state = exports.defaultState;
        }

        switch (action.type) {
          case 'ADD_CHOICE':
            {
              var addChoiceAction = action;
              var choice = {
                id: addChoiceAction.id,
                elementId: addChoiceAction.elementId,
                groupId: addChoiceAction.groupId,
                value: addChoiceAction.value,
                label: addChoiceAction.label || addChoiceAction.value,
                disabled: addChoiceAction.disabled || false,
                selected: false,
                active: true,
                score: 9999,
                customProperties: addChoiceAction.customProperties,
                placeholder: addChoiceAction.placeholder || false
              };
              /*
                A disabled choice appears in the choice dropdown but cannot be selected
                A selected choice has been added to the passed input's value (added as an item)
                An active choice appears within the choice dropdown
              */

              return __spreadArrays(state, [choice]);
            }

          case 'ADD_ITEM':
            {
              var addItemAction_1 = action; // When an item is added and it has an associated choice,
              // we want to disable it so it can't be chosen again

              if (addItemAction_1.choiceId > -1) {
                return state.map(function (obj) {
                  var choice = obj;

                  if (choice.id === parseInt("" + addItemAction_1.choiceId, 10)) {
                    choice.selected = true;
                  }

                  return choice;
                });
              }

              return state;
            }

          case 'REMOVE_ITEM':
            {
              var removeItemAction_1 = action; // When an item is removed and it has an associated choice,
              // we want to re-enable it so it can be chosen again

              if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
                return state.map(function (obj) {
                  var choice = obj;

                  if (choice.id === parseInt("" + removeItemAction_1.choiceId, 10)) {
                    choice.selected = false;
                  }

                  return choice;
                });
              }

              return state;
            }

          case 'FILTER_CHOICES':
            {
              var filterChoicesAction_1 = action;
              return state.map(function (obj) {
                var choice = obj; // Set active state based on whether choice is
                // within filtered results

                choice.active = filterChoicesAction_1.results.some(function (_a) {
                  var item = _a.item,
                    score = _a.score;

                  if (item.id === choice.id) {
                    choice.score = score;
                    return true;
                  }

                  return false;
                });
                return choice;
              });
            }

          case 'ACTIVATE_CHOICES':
            {
              var activateChoicesAction_1 = action;
              return state.map(function (obj) {
                var choice = obj;
                choice.active = activateChoicesAction_1.active;
                return choice;
              });
            }

          case 'CLEAR_CHOICES':
            {
              return exports.defaultState;
            }

          default:
            {
              return state;
            }
        }
      }

      exports.default = choices;

      /***/
    }),
/* 17 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultState = false;

      var general = function general(state, action) {
        if (state === void 0) {
          state = exports.defaultState;
        }

        switch (action.type) {
          case 'SET_IS_LOADING':
            {
              return action.isLoading;
            }

          default:
            {
              return state;
            }
        }
      };

      exports.default = general;

      /***/
    }),
/* 18 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var dropdown_1 = __importDefault(__webpack_require__(19));

      exports.Dropdown = dropdown_1.default;

      var container_1 = __importDefault(__webpack_require__(20));

      exports.Container = container_1.default;

      var input_1 = __importDefault(__webpack_require__(21));

      exports.Input = input_1.default;

      var list_1 = __importDefault(__webpack_require__(22));

      exports.List = list_1.default;

      var wrapped_input_1 = __importDefault(__webpack_require__(23));

      exports.WrappedInput = wrapped_input_1.default;

      var wrapped_select_1 = __importDefault(__webpack_require__(24));

      exports.WrappedSelect = wrapped_select_1.default;

      /***/
    }),
/* 19 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var Dropdown =
        /** @class */
        function () {
          function Dropdown(_a) {
            var element = _a.element,
              type = _a.type,
              classNames = _a.classNames;
            this.element = element;
            this.classNames = classNames;
            this.type = type;
            this.isActive = false;
          }

          Object.defineProperty(Dropdown.prototype, "distanceFromTopWindow", {
            /**
             * Bottom position of dropdown in viewport coordinates
             */
            get: function get() {
              return this.element.getBoundingClientRect().bottom;
            },
            enumerable: true,
            configurable: true
          });

          Dropdown.prototype.getChild = function (selector) {
            return this.element.querySelector(selector);
          };
          /**
           * Show dropdown to user by adding active state class
           */


          Dropdown.prototype.show = function () {
            this.element.classList.add(this.classNames.activeState);
            this.element.setAttribute('aria-expanded', 'true');
            this.isActive = true;
            return this;
          };
          /**
           * Hide dropdown from user
           */


          Dropdown.prototype.hide = function () {
            this.element.classList.remove(this.classNames.activeState);
            this.element.setAttribute('aria-expanded', 'false');
            this.isActive = false;
            return this;
          };

          return Dropdown;
        }();

      exports.default = Dropdown;

      /***/
    }),
/* 20 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var utils_1 = __webpack_require__(1);

      var constants_1 = __webpack_require__(0);

      var Container =
        /** @class */
        function () {
          function Container(_a) {
            var element = _a.element,
              type = _a.type,
              classNames = _a.classNames,
              position = _a.position;
            this.element = element;
            this.classNames = classNames;
            this.type = type;
            this.position = position;
            this.isOpen = false;
            this.isFlipped = false;
            this.isFocussed = false;
            this.isDisabled = false;
            this.isLoading = false;
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
          }

          Container.prototype.addEventListeners = function () {
            this.element.addEventListener('focus', this._onFocus);
            this.element.addEventListener('blur', this._onBlur);
          };

          Container.prototype.removeEventListeners = function () {
            this.element.removeEventListener('focus', this._onFocus);
            this.element.removeEventListener('blur', this._onBlur);
          };
          /**
           * Determine whether container should be flipped based on passed
           * dropdown position
           */


          Container.prototype.shouldFlip = function (dropdownPos) {
            if (typeof dropdownPos !== 'number') {
              return false;
            } // If flip is enabled and the dropdown bottom position is
            // greater than the window height flip the dropdown.


            var shouldFlip = false;

            if (this.position === 'auto') {
              shouldFlip = !window.matchMedia("(min-height: " + (dropdownPos + 1) + "px)").matches;
            } else if (this.position === 'top') {
              shouldFlip = true;
            }

            return shouldFlip;
          };

          Container.prototype.setActiveDescendant = function (activeDescendantID) {
            this.element.setAttribute('aria-activedescendant', activeDescendantID);
          };

          Container.prototype.removeActiveDescendant = function () {
            this.element.removeAttribute('aria-activedescendant');
          };

          Container.prototype.open = function (dropdownPos) {
            this.element.classList.add(this.classNames.openState);
            this.element.setAttribute('aria-expanded', 'true');
            this.isOpen = true;

            if (this.shouldFlip(dropdownPos)) {
              this.element.classList.add(this.classNames.flippedState);
              this.isFlipped = true;
            }
          };

          Container.prototype.close = function () {
            this.element.classList.remove(this.classNames.openState);
            this.element.setAttribute('aria-expanded', 'false');
            this.removeActiveDescendant();
            this.isOpen = false; // A dropdown flips if it does not have space within the page

            if (this.isFlipped) {
              this.element.classList.remove(this.classNames.flippedState);
              this.isFlipped = false;
            }
          };

          Container.prototype.focus = function () {
            if (!this.isFocussed) {
              this.element.focus();
            }
          };

          Container.prototype.addFocusState = function () {
            this.element.classList.add(this.classNames.focusState);
          };

          Container.prototype.removeFocusState = function () {
            this.element.classList.remove(this.classNames.focusState);
          };

          Container.prototype.enable = function () {
            this.element.classList.remove(this.classNames.disabledState);
            this.element.removeAttribute('aria-disabled');

            if (this.type === constants_1.SELECT_ONE_TYPE) {
              this.element.setAttribute('tabindex', '0');
            }

            this.isDisabled = false;
          };

          Container.prototype.disable = function () {
            this.element.classList.add(this.classNames.disabledState);
            this.element.setAttribute('aria-disabled', 'true');

            if (this.type === constants_1.SELECT_ONE_TYPE) {
              this.element.setAttribute('tabindex', '-1');
            }

            this.isDisabled = true;
          };

          Container.prototype.wrap = function (element) {
            utils_1.wrap(element, this.element);
          };

          Container.prototype.unwrap = function (element) {
            if (this.element.parentNode) {
              // Move passed element outside this element
              this.element.parentNode.insertBefore(element, this.element); // Remove this element

              this.element.parentNode.removeChild(this.element);
            }
          };

          Container.prototype.addLoadingState = function () {
            this.element.classList.add(this.classNames.loadingState);
            this.element.setAttribute('aria-busy', 'true');
            this.isLoading = true;
          };

          Container.prototype.removeLoadingState = function () {
            this.element.classList.remove(this.classNames.loadingState);
            this.element.removeAttribute('aria-busy');
            this.isLoading = false;
          };

          Container.prototype._onFocus = function () {
            this.isFocussed = true;
          };

          Container.prototype._onBlur = function () {
            this.isFocussed = false;
          };

          return Container;
        }();

      exports.default = Container;

      /***/
    }),
/* 21 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var utils_1 = __webpack_require__(1);

      var constants_1 = __webpack_require__(0);

      var Input =
        /** @class */
        function () {
          function Input(_a) {
            var element = _a.element,
              type = _a.type,
              classNames = _a.classNames,
              preventPaste = _a.preventPaste;
            this.element = element;
            this.type = type;
            this.classNames = classNames;
            this.preventPaste = preventPaste;
            this.isFocussed = this.element.isEqualNode(document.activeElement);
            this.isDisabled = element.disabled;
            this._onPaste = this._onPaste.bind(this);
            this._onInput = this._onInput.bind(this);
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
          }

          Object.defineProperty(Input.prototype, "placeholder", {
            set: function set(placeholder) {
              this.element.placeholder = placeholder;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Input.prototype, "value", {
            get: function get() {
              return utils_1.sanitise(this.element.value);
            },
            set: function set(value) {
              this.element.value = value;
            },
            enumerable: true,
            configurable: true
          });

          Input.prototype.addEventListeners = function () {
            this.element.addEventListener('paste', this._onPaste);
            this.element.addEventListener('input', this._onInput, {
              passive: true
            });
            this.element.addEventListener('focus', this._onFocus, {
              passive: true
            });
            this.element.addEventListener('blur', this._onBlur, {
              passive: true
            });
          };

          Input.prototype.removeEventListeners = function () {
            this.element.removeEventListener('input', this._onInput);
            this.element.removeEventListener('paste', this._onPaste);
            this.element.removeEventListener('focus', this._onFocus);
            this.element.removeEventListener('blur', this._onBlur);
          };

          Input.prototype.enable = function () {
            this.element.removeAttribute('disabled');
            this.isDisabled = false;
          };

          Input.prototype.disable = function () {
            this.element.setAttribute('disabled', '');
            this.isDisabled = true;
          };

          Input.prototype.focus = function () {
            if (!this.isFocussed) {
              this.element.focus();
            }
          };

          Input.prototype.blur = function () {
            if (this.isFocussed) {
              this.element.blur();
            }
          };

          Input.prototype.clear = function (setWidth) {
            if (setWidth === void 0) {
              setWidth = true;
            }

            if (this.element.value) {
              this.element.value = '';
            }

            if (setWidth) {
              this.setWidth();
            }

            return this;
          };
          /**
           * Set the correct input width based on placeholder
           * value or input value
           */


          Input.prototype.setWidth = function () {
            // Resize input to contents or placeholder
            var _a = this.element,
              style = _a.style,
              value = _a.value,
              placeholder = _a.placeholder;
            style.minWidth = placeholder.length + 1 + "ch";
            style.width = value.length + 1 + "ch";
          };

          Input.prototype.setActiveDescendant = function (activeDescendantID) {
            this.element.setAttribute('aria-activedescendant', activeDescendantID);
          };

          Input.prototype.removeActiveDescendant = function () {
            this.element.removeAttribute('aria-activedescendant');
          };

          Input.prototype._onInput = function () {
            if (this.type !== constants_1.SELECT_ONE_TYPE) {
              this.setWidth();
            }
          };

          Input.prototype._onPaste = function (event) {
            if (this.preventPaste) {
              event.preventDefault();
            }
          };

          Input.prototype._onFocus = function () {
            this.isFocussed = true;
          };

          Input.prototype._onBlur = function () {
            this.isFocussed = false;
          };

          return Input;
        }();

      exports.default = Input;

      /***/
    }),
/* 22 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var constants_1 = __webpack_require__(0);

      var List =
        /** @class */
        function () {
          function List(_a) {
            var element = _a.element;
            this.element = element;
            this.scrollPos = this.element.scrollTop;
            this.height = this.element.offsetHeight;
          }

          List.prototype.clear = function () {
            this.element.innerHTML = '';
          };

          List.prototype.append = function (node) {
            this.element.appendChild(node);
          };

          List.prototype.getChild = function (selector) {
            return this.element.querySelector(selector);
          };

          List.prototype.hasChildren = function () {
            return this.element.hasChildNodes();
          };

          List.prototype.scrollToTop = function () {
            this.element.scrollTop = 0;
          };

          List.prototype.scrollToChildElement = function (element, direction) {
            var _this = this;

            if (!element) {
              return;
            }

            var listHeight = this.element.offsetHeight; // Scroll position of dropdown

            var listScrollPosition = this.element.scrollTop + listHeight;
            var elementHeight = element.offsetHeight; // Distance from bottom of element to top of parent

            var elementPos = element.offsetTop + elementHeight; // Difference between the element and scroll position

            var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
            requestAnimationFrame(function () {
              _this._animateScroll(destination, direction);
            });
          };

          List.prototype._scrollDown = function (scrollPos, strength, destination) {
            var easing = (destination - scrollPos) / strength;
            var distance = easing > 1 ? easing : 1;
            this.element.scrollTop = scrollPos + distance;
          };

          List.prototype._scrollUp = function (scrollPos, strength, destination) {
            var easing = (scrollPos - destination) / strength;
            var distance = easing > 1 ? easing : 1;
            this.element.scrollTop = scrollPos - distance;
          };

          List.prototype._animateScroll = function (destination, direction) {
            var _this = this;

            var strength = constants_1.SCROLLING_SPEED;
            var choiceListScrollTop = this.element.scrollTop;
            var continueAnimation = false;

            if (direction > 0) {
              this._scrollDown(choiceListScrollTop, strength, destination);

              if (choiceListScrollTop < destination) {
                continueAnimation = true;
              }
            } else {
              this._scrollUp(choiceListScrollTop, strength, destination);

              if (choiceListScrollTop > destination) {
                continueAnimation = true;
              }
            }

            if (continueAnimation) {
              requestAnimationFrame(function () {
                _this._animateScroll(destination, direction);
              });
            }
          };

          return List;
        }();

      exports.default = List;

      /***/
    }),
/* 23 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __extends = this && this.__extends || function () {
        var _extendStatics = function extendStatics(d, b) {
          _extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return _extendStatics(d, b);
        };

        return function (d, b) {
          _extendStatics(d, b);

          function __() {
            this.constructor = d;
          }

          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var wrapped_element_1 = __importDefault(__webpack_require__(5));

      var WrappedInput =
        /** @class */
        function (_super) {
          __extends(WrappedInput, _super);

          function WrappedInput(_a) {
            var element = _a.element,
              classNames = _a.classNames,
              delimiter = _a.delimiter;

            var _this = _super.call(this, {
              element: element,
              classNames: classNames
            }) || this;

            _this.delimiter = delimiter;
            return _this;
          }

          Object.defineProperty(WrappedInput.prototype, "value", {
            get: function get() {
              return this.element.value;
            },
            set: function set(value) {
              this.element.setAttribute('value', value);
              this.element.value = value;
            },
            enumerable: true,
            configurable: true
          });
          return WrappedInput;
        }(wrapped_element_1.default);

      exports.default = WrappedInput;

      /***/
    }),
/* 24 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      var __extends = this && this.__extends || function () {
        var _extendStatics = function extendStatics(d, b) {
          _extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return _extendStatics(d, b);
        };

        return function (d, b) {
          _extendStatics(d, b);

          function __() {
            this.constructor = d;
          }

          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var wrapped_element_1 = __importDefault(__webpack_require__(5));

      var WrappedSelect =
        /** @class */
        function (_super) {
          __extends(WrappedSelect, _super);

          function WrappedSelect(_a) {
            var element = _a.element,
              classNames = _a.classNames,
              template = _a.template;

            var _this = _super.call(this, {
              element: element,
              classNames: classNames
            }) || this;

            _this.template = template;
            return _this;
          }

          Object.defineProperty(WrappedSelect.prototype, "placeholderOption", {
            get: function get() {
              return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                this.element.querySelector('option[placeholder]');
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(WrappedSelect.prototype, "optionGroups", {
            get: function get() {
              return Array.from(this.element.getElementsByTagName('OPTGROUP'));
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(WrappedSelect.prototype, "options", {
            get: function get() {
              return Array.from(this.element.options);
            },
            set: function set(options) {
              var _this = this;

              var fragment = document.createDocumentFragment();

              var addOptionToFragment = function addOptionToFragment(data) {
                // Create a standard select option
                var option = _this.template(data); // Append it to fragment


                fragment.appendChild(option);
              }; // Add each list item to list


              options.forEach(function (optionData) {
                return addOptionToFragment(optionData);
              });
              this.appendDocFragment(fragment);
            },
            enumerable: true,
            configurable: true
          });

          WrappedSelect.prototype.appendDocFragment = function (fragment) {
            this.element.innerHTML = '';
            this.element.appendChild(fragment);
          };

          return WrappedSelect;
        }(wrapped_element_1.default);

      exports.default = WrappedSelect;

      /***/
    }),
/* 25 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      /**
       * Helpers to create HTML elements used by Choices
       * Can be overridden by providing `callbackOnCreateTemplates` option
       */

      var templates = {
        containerOuter: function containerOuter(_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType) {
          var containerOuter = _a.containerOuter;
          var div = Object.assign(document.createElement('div'), {
            className: containerOuter
          });
          div.dataset.type = passedElementType;

          if (dir) {
            div.dir = dir;
          }

          if (isSelectOneElement) {
            div.tabIndex = 0;
          }

          if (isSelectElement) {
            div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');

            if (searchEnabled) {
              div.setAttribute('aria-autocomplete', 'list');
            }
          }

          div.setAttribute('aria-haspopup', 'true');
          div.setAttribute('aria-expanded', 'false');
          return div;
        },
        containerInner: function containerInner(_a) {
          var containerInner = _a.containerInner;
          return Object.assign(document.createElement('div'), {
            className: containerInner
          });
        },
        itemList: function itemList(_a, isSelectOneElement) {
          var list = _a.list,
            listSingle = _a.listSingle,
            listItems = _a.listItems;
          return Object.assign(document.createElement('div'), {
            className: list + " " + (isSelectOneElement ? listSingle : listItems)
          });
        },
        placeholder: function placeholder(_a, value) {
          var placeholder = _a.placeholder;
          return Object.assign(document.createElement('div'), {
            className: placeholder,
            innerHTML: value
          });
        },
        item: function item(_a, _b, removeItemButton) {
          var item = _a.item,
            button = _a.button,
            highlightedState = _a.highlightedState,
            itemSelectable = _a.itemSelectable,
            placeholder = _a.placeholder;
          var id = _b.id,
            value = _b.value,
            label = _b.label,
            customProperties = _b.customProperties,
            active = _b.active,
            disabled = _b.disabled,
            highlighted = _b.highlighted,
            isPlaceholder = _b.placeholder;
          var div = Object.assign(document.createElement('div'), {
            className: item,
            innerHTML: label
          });
          Object.assign(div.dataset, {
            item: '',
            id: id,
            value: value,
            customProperties: customProperties
          });

          if (active) {
            div.setAttribute('aria-selected', 'true');
          }

          if (disabled) {
            div.setAttribute('aria-disabled', 'true');
          }

          if (isPlaceholder) {
            div.classList.add(placeholder);
          }

          div.classList.add(highlighted ? highlightedState : itemSelectable);

          if (removeItemButton) {
            if (disabled) {
              div.classList.remove(itemSelectable);
            }

            div.dataset.deletable = '';
            /** @todo This MUST be localizable, not hardcoded! */

            var REMOVE_ITEM_TEXT = 'Remove item';
            var removeButton = Object.assign(document.createElement('button'), {
              type: 'button',
              className: button,
              innerHTML: REMOVE_ITEM_TEXT
            });
            removeButton.setAttribute('aria-label', REMOVE_ITEM_TEXT + ": '" + value + "'");
            removeButton.dataset.button = '';
            div.appendChild(removeButton);
          }

          return div;
        },
        choiceList: function choiceList(_a, isSelectOneElement) {
          var list = _a.list;
          var div = Object.assign(document.createElement('div'), {
            className: list
          });

          if (!isSelectOneElement) {
            div.setAttribute('aria-multiselectable', 'true');
          }

          div.setAttribute('role', 'listbox');
          return div;
        },
        choiceGroup: function choiceGroup(_a, _b) {
          var group = _a.group,
            groupHeading = _a.groupHeading,
            itemDisabled = _a.itemDisabled;
          var id = _b.id,
            value = _b.value,
            disabled = _b.disabled;
          var div = Object.assign(document.createElement('div'), {
            className: group + " " + (disabled ? itemDisabled : '')
          });
          div.setAttribute('role', 'group');
          Object.assign(div.dataset, {
            group: '',
            id: id,
            value: value
          });

          if (disabled) {
            div.setAttribute('aria-disabled', 'true');
          }

          div.appendChild(Object.assign(document.createElement('div'), {
            className: groupHeading,
            innerHTML: value
          }));
          return div;
        },
        choice: function choice(_a, _b, selectText) {
          var item = _a.item,
            itemChoice = _a.itemChoice,
            itemSelectable = _a.itemSelectable,
            selectedState = _a.selectedState,
            itemDisabled = _a.itemDisabled,
            placeholder = _a.placeholder;
          var id = _b.id,
            value = _b.value,
            label = _b.label,
            groupId = _b.groupId,
            elementId = _b.elementId,
            isDisabled = _b.disabled,
            isSelected = _b.selected,
            isPlaceholder = _b.placeholder;
          var div = Object.assign(document.createElement('div'), {
            id: elementId,
            innerHTML: label,
            className: item + " " + itemChoice
          });

          if (isSelected) {
            div.classList.add(selectedState);
          }

          if (isPlaceholder) {
            div.classList.add(placeholder);
          }

          div.setAttribute('role', groupId && groupId > 0 ? 'treeitem' : 'option');
          Object.assign(div.dataset, {
            choice: '',
            id: id,
            value: value,
            selectText: selectText
          });

          if (isDisabled) {
            div.classList.add(itemDisabled);
            div.dataset.choiceDisabled = '';
            div.setAttribute('aria-disabled', 'true');
          } else {
            div.classList.add(itemSelectable);
            div.dataset.choiceSelectable = '';
          }

          return div;
        },
        input: function input(_a, placeholderValue) {
          var input = _a.input,
            inputCloned = _a.inputCloned;
          var inp = Object.assign(document.createElement('input'), {
            type: 'text',
            className: input + " " + inputCloned,
            autocomplete: 'off',
            autocapitalize: 'off',
            spellcheck: false
          });
          inp.setAttribute('role', 'textbox');
          inp.setAttribute('aria-autocomplete', 'list');
          inp.setAttribute('aria-label', placeholderValue);
          return inp;
        },
        dropdown: function dropdown(_a) {
          var list = _a.list,
            listDropdown = _a.listDropdown;
          var div = document.createElement('div');
          div.classList.add(list, listDropdown);
          div.setAttribute('aria-expanded', 'false');
          return div;
        },
        notice: function notice(_a, innerHTML, type) {
          var item = _a.item,
            itemChoice = _a.itemChoice,
            noResults = _a.noResults,
            noChoices = _a.noChoices;

          if (type === void 0) {
            type = '';
          }

          var classes = [item, itemChoice];

          if (type === 'no-choices') {
            classes.push(noChoices);
          } else if (type === 'no-results') {
            classes.push(noResults);
          }

          return Object.assign(document.createElement('div'), {
            innerHTML: innerHTML,
            className: classes.join(' ')
          });
        },
        option: function option(_a) {
          var label = _a.label,
            value = _a.value,
            customProperties = _a.customProperties,
            active = _a.active,
            disabled = _a.disabled;
          var opt = new Option(label, value, false, active);

          if (customProperties) {
            opt.dataset.customProperties = "" + customProperties;
          }

          opt.disabled = !!disabled;
          return opt;
        }
      };
      exports.default = templates;

      /***/
    }),
/* 26 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var constants_1 = __webpack_require__(0);

      exports.addChoice = function (_a) {
        var value = _a.value,
          label = _a.label,
          id = _a.id,
          groupId = _a.groupId,
          disabled = _a.disabled,
          elementId = _a.elementId,
          customProperties = _a.customProperties,
          placeholder = _a.placeholder,
          keyCode = _a.keyCode;
        return {
          type: constants_1.ACTION_TYPES.ADD_CHOICE,
          value: value,
          label: label,
          id: id,
          groupId: groupId,
          disabled: disabled,
          elementId: elementId,
          customProperties: customProperties,
          placeholder: placeholder,
          keyCode: keyCode
        };
      };

      exports.filterChoices = function (results) {
        return {
          type: constants_1.ACTION_TYPES.FILTER_CHOICES,
          results: results
        };
      };

      exports.activateChoices = function (active) {
        if (active === void 0) {
          active = true;
        }

        return {
          type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
          active: active
        };
      };

      exports.clearChoices = function () {
        return {
          type: constants_1.ACTION_TYPES.CLEAR_CHOICES
        };
      };

      /***/
    }),
/* 27 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var constants_1 = __webpack_require__(0);

      exports.addItem = function (_a) {
        var value = _a.value,
          label = _a.label,
          id = _a.id,
          choiceId = _a.choiceId,
          groupId = _a.groupId,
          customProperties = _a.customProperties,
          placeholder = _a.placeholder,
          keyCode = _a.keyCode;
        return {
          type: constants_1.ACTION_TYPES.ADD_ITEM,
          value: value,
          label: label,
          id: id,
          choiceId: choiceId,
          groupId: groupId,
          customProperties: customProperties,
          placeholder: placeholder,
          keyCode: keyCode
        };
      };

      exports.removeItem = function (id, choiceId) {
        return {
          type: constants_1.ACTION_TYPES.REMOVE_ITEM,
          id: id,
          choiceId: choiceId
        };
      };

      exports.highlightItem = function (id, highlighted) {
        return {
          type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
          id: id,
          highlighted: highlighted
        };
      };

      /***/
    }),
/* 28 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var constants_1 = __webpack_require__(0);

      exports.addGroup = function (_a) {
        var value = _a.value,
          id = _a.id,
          active = _a.active,
          disabled = _a.disabled;
        return {
          type: constants_1.ACTION_TYPES.ADD_GROUP,
          value: value,
          id: id,
          active: active,
          disabled: disabled
        };
      };

      /***/
    }),
/* 29 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var constants_1 = __webpack_require__(0);

      exports.clearAll = function () {
        return {
          type: constants_1.ACTION_TYPES.CLEAR_ALL
        };
      };

      exports.resetTo = function (state) {
        return {
          type: constants_1.ACTION_TYPES.RESET_TO,
          state: state
        };
      };

      exports.setIsLoading = function (isLoading) {
        return {
          type: constants_1.ACTION_TYPES.SET_IS_LOADING,
          isLoading: isLoading
        };
      };

      /***/
    })
/******/])["default"];
});